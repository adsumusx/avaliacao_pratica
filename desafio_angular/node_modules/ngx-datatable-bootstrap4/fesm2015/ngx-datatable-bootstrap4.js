import { ContentChild, Directive, Input, Component, forwardRef, Inject, EventEmitter, Output, ContentChildren, ViewChildren, HostListener, ElementRef, Renderer, Pipe, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @template T
 */
class DataTableColumn {
    constructor() {
        // for [ngClass]
        this.styleClassObject = {};
        this.sortable = false;
        this.resizable = false;
        this.visible = true;
    }
    /**
     * @param {?} row
     * @param {?} index
     * @return {?}
     */
    getCellColor(row, index) {
        if (this.cellColors !== undefined) {
            return (/** @type {?} */ (this.cellColors))(row.item, row, this, index);
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._initCellClass();
    }
    /**
     * @return {?}
     */
    _initCellClass() {
        if (!this.styleClass && this.property) {
            if (/^[a-zA-Z0-9_]+$/.test(this.property)) {
                this.styleClass = 'column-' + this.property;
            }
            else {
                this.styleClass = 'column-' + this.property.replace(/[^a-zA-Z0-9_]/g, '');
            }
        }
        if (this.styleClass != null) {
            this.styleClassObject = {
                [this.styleClass]: true
            };
        }
    }
}
DataTableColumn.decorators = [
    { type: Directive, args: [{
                selector: 'data-table-column'
            },] },
];
DataTableColumn.propDecorators = {
    header: [{ type: Input }],
    sortable: [{ type: Input }],
    resizable: [{ type: Input }],
    property: [{ type: Input }],
    styleClass: [{ type: Input }],
    cellColors: [{ type: Input }],
    width: [{ type: Input }],
    visible: [{ type: Input }],
    cellTemplate: [{ type: ContentChild, args: ['cellTemplate',] }],
    headerTemplate: [{ type: ContentChild, args: ['headerTemplate',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @template T
 */
class DataTablePagination$$1 {
    /**
     * @param {?} dataTable
     */
    constructor(dataTable) {
        this.dataTable = dataTable;
    }
    /**
     * @return {?}
     */
    get maxPage() {
        return Math.ceil(this.dataTable.itemCount / this.dataTable.limit);
    }
    /**
     * @return {?}
     */
    get limit() {
        return this.dataTable.limit;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set limit(value) {
        if (Number(value) > 0) {
            this.dataTable.limit = Math.floor(+value);
        }
    }
    /**
     * @return {?}
     */
    get page() {
        return this.dataTable.page;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set page(value) {
        if (Number(value) > 0) {
            this.dataTable.page = Math.floor(+value);
        }
    }
    /**
     * @return {?}
     */
    pageBack() {
        this.dataTable.offset -= Math.min(this.dataTable.limit, this.dataTable.offset);
    }
    /**
     * @return {?}
     */
    pageForward() {
        this.dataTable.offset += this.dataTable.limit;
    }
    /**
     * @return {?}
     */
    pageFirst() {
        this.dataTable.offset = 0;
    }
    /**
     * @return {?}
     */
    pageLast() {
        this.dataTable.offset = (this.maxPage - 1) * this.dataTable.limit;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    keyPress(event) {
        let /** @type {?} */ inputChar = String.fromCharCode(event.charCode);
        if (!(Number(inputChar) >= 0)) {
            event.preventDefault();
        }
    }
}
DataTablePagination$$1.decorators = [
    { type: Component, args: [{
                selector: 'data-table-pagination',
                template: `<div class="navbar p-0 pagination-component">
  <div>
    {{dataTable.translations.paginationRange}}:&nbsp;{{dataTable.offset < 0 ? 0 : dataTable.offset + 1}}&nbsp;-
    {{[dataTable.offset + dataTable.limit , dataTable.itemCount] | min}}&nbsp;/&nbsp;{{dataTable.itemCount}}
  </div>
  <ul class="nav justify-content-end">
    <li class="nav-item pagination-limit">
      <div class="input-group">
        <div class="input-group-prepend">
          <span class="input-group-text">{{dataTable.translations.paginationLimit}}:</span>
        </div>
        <input #limitInput type="number" class="form-control" min="1" step="1"
               [ngModel]="limit" (blur)="limit = limitInput.value"
               (keyup.enter)="limit = limitInput.value"
               (keyup.esc)="limitInput.value = limit"
               (keypress)="keyPress($event)"/>
      </div>
    </li>
    <li class="nav-item">
      <button [disabled]="dataTable.offset <= 0" (click)="pageFirst()" class="btn btn-default">&laquo;</button>
      <button [disabled]="dataTable.offset <= 0" (click)="pageBack()" class="btn btn-default">&lsaquo;</button>
      <div class="d-inline-block">
        <div class="input-group">
          <input #pageInput type="number" class="form-control" min="1" step="1" max="{{maxPage}}"
                 [ngModel]="page" (blur)="page = pageInput.value"
                 (keyup.enter)="page = pageInput.value" (keyup.esc)="pageInput.value = page"
                 (keypress)="keyPress($event)"/>
          <div class="input-group-append">
            <span class="input-group-text">/&nbsp;{{dataTable.lastPage}}</span>
          </div>
        </div>
      </div>
      <button [disabled]="(dataTable.offset + dataTable.limit) >= dataTable.itemCount" (click)="pageForward()"
              class="btn btn-default">&rsaquo;
      </button>
      <button [disabled]="(dataTable.offset + dataTable.limit) >= dataTable.itemCount" (click)="pageLast()"
              class="btn btn-default">&raquo;
      </button>
    </li>
  </ul>
</div>
`,
                styles: [`.pagination-component .pagination-limit{margin-right:1rem}.pagination-component .pagination-limit input{width:75px}.pagination-component .btn{margin-top:-3px}`]
            },] },
];
/** @nocollapse */
DataTablePagination$$1.ctorParameters = () => [
    { type: DataTable$$1, decorators: [{ type: Inject, args: [forwardRef(() => DataTable$$1),] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @template T
 */
class DataTableRow$$1 {
    /**
     * @param {?} dataTable
     */
    constructor(dataTable) {
        this.dataTable = dataTable;
        this.selectedChange = new EventEmitter();
        this._this = this;
    }
    /**
     * @return {?}
     */
    get selected() {
        return this._selected;
    }
    /**
     * @param {?} selected
     * @return {?}
     */
    set selected(selected) {
        this._selected = selected;
        this.selectedChange.emit(selected);
    }
    /**
     * @return {?}
     */
    get displayIndex() {
        if (this.dataTable.pagination) {
            return this.dataTable.displayParams.offset + this.index + 1;
        }
        else {
            return this.index + 1;
        }
    }
    /**
     * @return {?}
     */
    getTooltip() {
        if (this.dataTable.rowTooltip) {
            return this.dataTable.rowTooltip(this.item, this, this.index);
        }
        return '';
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.selected = false;
    }
}
DataTableRow$$1.decorators = [
    { type: Component, args: [{
                selector: '[dataTableRow]',
                template: `<tr class="data-table-row"
    [title]="getTooltip()"
    [style.background-color]="dataTable.getRowColor(item, index, _this)"
    [class.row-odd]="index % 2 === 0"
    [class.row-even]="index % 2 === 1"
    [class.selected]="selected"
    [class.clickable]="dataTable.selectOnRowClick"
    (dblclick)="dataTable.rowDoubleClicked(_this, $event)"
    (click)="dataTable.rowClicked(_this, $event)">
  <td [hide]="!dataTable.expandColumnVisible" class="row-expand-button"
      (click)="expanded = !expanded; $event.stopPropagation(); dataTable.rowExpanded(_this, $event)">
    <span class="fa fa-arrow-circle-o-right" [hide]="expanded"></span>
    <span class="fa fa-arrow-circle-o-down" [hide]="!expanded"></span>
  </td>
  <td [hide]="!dataTable.indexColumnVisible" class="index-column" [textContent]="displayIndex"></td>
  <td [hide]="!dataTable.selectColumnVisible" class="select-column">
    <input type="checkbox" [(ngModel)]="selected"/>
  </td>
  <td *ngFor="let column of dataTable.columns" [hide]="!column.visible" [ngClass]="column.styleClassObject"
      class="data-column"
      [style.background-color]="column.getCellColor(_this, index)"
      (click)="dataTable.cellClicked(column, _this, $event)">
    <div *ngIf="!column.cellTemplate" [textContent]="item[column.property]"></div>
    <ng-container *ngIf="column.cellTemplate" [ngTemplateOutlet]="column.cellTemplate"
         [ngTemplateOutletContext]="{column: column, row: _this, item: item}"></ng-container>
  </td>
</tr>
<tr *ngIf="dataTable.expandableRows" [hide]="!expanded" class="row-expansion">
  <td [attr.colspan]="dataTable.columnCount">
    <ng-container [ngTemplateOutlet]="dataTable.expandTemplate"
                  [ngTemplateOutletContext]="{row: _this, item: item}"></ng-container>
  </td>
</tr>
`,
                styles: [`.select-column{text-align:center}.row-expand-button{cursor:pointer;text-align:center}.clickable{cursor:pointer}`]
            },] },
];
/** @nocollapse */
DataTableRow$$1.ctorParameters = () => [
    { type: DataTable$$1, decorators: [{ type: Inject, args: [forwardRef(() => DataTable$$1),] }] }
];
DataTableRow$$1.propDecorators = {
    item: [{ type: Input }],
    index: [{ type: Input }],
    selectedChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} event
 * @param {?} __1
 * @return {?}
 */
function drag(event, { move, up }) {
    let /** @type {?} */ startX = event.pageX;
    let /** @type {?} */ startY = event.pageY;
    let /** @type {?} */ x = startX;
    let /** @type {?} */ y = startY;
    let /** @type {?} */ moved = false;
    /**
     * @param {?} e
     * @return {?}
     */
    function mouseMoveHandler(e) {
        let /** @type {?} */ dx = e.pageX - x;
        let /** @type {?} */ dy = e.pageY - y;
        x = e.pageX;
        y = e.pageY;
        if (dx || dy) {
            moved = true;
        }
        move(e, dx, dy, x, y);
        e.preventDefault(); // to avoid text selection
    }
    /**
     * @param {?} e
     * @return {?}
     */
    function mouseUpHandler(e) {
        x = e.pageX;
        y = e.pageY;
        document.removeEventListener('mousemove', mouseMoveHandler);
        document.removeEventListener('mouseup', mouseUpHandler);
        if (up) {
            up(e, x, y, moved);
        }
    }
    document.addEventListener('mousemove', mouseMoveHandler);
    document.addEventListener('mouseup', mouseUpHandler);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ defaultTranslations = /** @type {?} */ ({
    indexColumn: 'index',
    selectColumn: 'select',
    expandColumn: 'expand',
    paginationLimit: 'Limit',
    paginationRange: 'Results'
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @template T
 */
class DataTable$$1 {
    constructor() {
        this._sortAsc = true;
        this._offset = 0;
        this._limit = 10;
        this._items = [];
        this._scheduledReload = null;
        this._selectAllCheckbox = false;
        this._displayParams = /** @type {?} */ ({});
        this._reloading = false;
        this._resizeInProgress = false;
        this.selectedRows = [];
        this.resizeLimit = 30;
        this.pagination = true;
        this.indexColumn = true;
        this.indexColumnHeader = '';
        this.selectColumn = false;
        this.multiSelect = true;
        this.substituteRows = true;
        this.expandableRows = false;
        this.translations = defaultTranslations;
        this.selectOnRowClick = false;
        this.autoReload = true;
        this.showReloading = false;
        // event handlers:
        this.rowClick = new EventEmitter();
        this.rowExpand = new EventEmitter();
        this.rowDoubleClick = new EventEmitter();
        this.headerClick = new EventEmitter();
        this.cellClick = new EventEmitter();
        this.reload = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get items() {
        return this._items;
    }
    /**
     * @param {?} items
     * @return {?}
     */
    set items(items) {
        this._items = items;
        this._onReloadFinished();
    }
    /**
     * @return {?}
     */
    get sortBy() {
        return this._sortBy;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set sortBy(value) {
        this._sortBy = value;
        this._triggerReload();
    }
    /**
     * @return {?}
     */
    get sortAsc() {
        return this._sortAsc;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set sortAsc(value) {
        this._sortAsc = value;
        this._triggerReload();
    }
    /**
     * @return {?}
     */
    get offset() {
        return this._offset;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set offset(value) {
        this._offset = value;
        this._triggerReload();
    }
    /**
     * @return {?}
     */
    get limit() {
        return this._limit;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set limit(value) {
        this._limit = value;
        this._triggerReload();
    }
    /**
     * @return {?}
     */
    get page() {
        return Math.floor(this.offset / this.limit) + 1;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set page(value) {
        this.offset = (value - 1) * this.limit;
    }
    /**
     * @return {?}
     */
    get lastPage() {
        return Math.ceil(this.itemCount / this.limit);
    }
    /**
     * @return {?}
     */
    get reloading() {
        return this._reloading;
    }
    /**
     * @return {?}
     */
    get displayParams() {
        return this._displayParams;
    }
    /**
     * @return {?}
     */
    get selectAllCheckbox() {
        return this._selectAllCheckbox;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set selectAllCheckbox(value) {
        this._selectAllCheckbox = value;
        this._onSelectAllChanged(value);
    }
    /**
     * @return {?}
     */
    get columnCount() {
        let /** @type {?} */ count = 0;
        count += this.indexColumnVisible ? 1 : 0;
        count += this.selectColumnVisible ? 1 : 0;
        count += this.expandColumnVisible ? 1 : 0;
        this.columns.toArray().forEach(column => {
            count += column.visible ? 1 : 0;
        });
        return count;
    }
    /**
     * @return {?}
     */
    get substituteItems() {
        return Array.from({ length: /** @type {?} */ ((this.displayParams)).limit - this.items.length });
    }
    /**
     * @param {?} item
     * @param {?} index
     * @param {?} row
     * @return {?}
     */
    getRowColor(item, index, row) {
        if (this.rowColors !== undefined) {
            return (/** @type {?} */ (this.rowColors))(item, row, index);
        }
    }
    /**
     * @param {?} sortBy
     * @param {?} asc
     * @return {?}
     */
    sort(sortBy, asc) {
        this.sortBy = sortBy;
        this.sortAsc = asc;
    }
    /**
     * @return {?}
     */
    reloadItems() {
        this._reloading = true;
        this.reload.emit(this._getRemoteParameters());
    }
    /**
     * @param {?} row
     * @param {?} event
     * @return {?}
     */
    rowClicked(row, event) {
        this.rowClick.emit({ row, event });
    }
    /**
     * @param {?} row
     * @param {?} event
     * @return {?}
     */
    rowDoubleClicked(row, event) {
        this.rowDoubleClick.emit({ row, event });
    }
    /**
     * @param {?} column
     * @param {?} event
     * @return {?}
     */
    headerClicked(column, event) {
        if (!this._resizeInProgress) {
            this.headerClick.emit({ column, event });
        }
        else {
            // this is because I can't prevent click from mousup of the drag end
            this._resizeInProgress = false;
        }
    }
    /**
     * @param {?} column
     * @param {?} row
     * @param {?} event
     * @return {?}
     */
    cellClicked(column, row, event) {
        this.cellClick.emit({ row, column, event });
    }
    /**
     * @param {?} row
     * @param {?} event
     * @return {?}
     */
    rowExpanded(row, event) {
        this.rowExpand.emit({ row, event });
    }
    /**
     * @param {?} row
     * @return {?}
     */
    onRowSelectChanged(row) {
        // maintain the selectedRow(s) view
        if (this.multiSelect) {
            let /** @type {?} */ index = this.selectedRows.indexOf(row);
            if (row.selected && index < 0) {
                this.selectedRows.push(row);
            }
            else if (!row.selected && index >= 0) {
                this.selectedRows.splice(index, 1);
            }
        }
        else {
            if (row.selected) {
                this.selectedRow = row;
            }
            else if (this.selectedRow === row) {
                this.selectedRow = undefined;
            }
        }
        // unselect all other rows:
        if (row.selected && !this.multiSelect) {
            this.rows.toArray().filter(row_ => row_.selected).forEach(row_ => {
                if (row_ !== row) {
                    // avoid endless loop
                    row_.selected = false;
                }
            });
        }
    }
    /**
     * @param {?} event
     * @param {?} column
     * @param {?} columnElement
     * @return {?}
     */
    resizeColumnStart(event, column, columnElement) {
        this._resizeInProgress = true;
        drag(event, {
            move: (moveEvent, dx) => {
                if (this._isResizeInLimit(columnElement, dx)) {
                    column.width = columnElement.offsetWidth + dx;
                }
            },
        });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._initDefaultValues();
        this._initDefaultClickEvents();
        this._updateDisplayParams();
        if (this.autoReload && this._scheduledReload == null) {
            this.reloadItems();
        }
    }
    /**
     * @return {?}
     */
    _initDefaultValues() {
        this.indexColumnVisible = this.indexColumn;
        this.selectColumnVisible = this.selectColumn;
        this.expandColumnVisible = this.expandableRows;
    }
    /**
     * @return {?}
     */
    _initDefaultClickEvents() {
        this.headerClick.subscribe(tableEvent => this._sortColumn(tableEvent.column));
        if (this.selectOnRowClick) {
            this.rowClick.subscribe(tableEvent => tableEvent.row.selected = !tableEvent.row.selected);
        }
    }
    /**
     * @return {?}
     */
    _onReloadFinished() {
        this._updateDisplayParams();
        this._selectAllCheckbox = false;
        this._reloading = false;
    }
    /**
     * @return {?}
     */
    _updateDisplayParams() {
        this._displayParams = {
            sortBy: this.sortBy,
            sortAsc: this.sortAsc,
            offset: this.offset,
            limit: this.limit
        };
    }
    /**
     * @return {?}
     */
    _triggerReload() {
        // for avoiding cascading reloads if multiple params are set at once:
        if (this._scheduledReload) {
            clearTimeout(this._scheduledReload);
        }
        this._scheduledReload = setTimeout(() => {
            this.reloadItems();
        });
    }
    /**
     * @return {?}
     */
    _getRemoteParameters() {
        let /** @type {?} */ params = /** @type {?} */ ({});
        if (this.sortBy) {
            params.sortBy = this.sortBy;
            params.sortAsc = this.sortAsc;
        }
        if (this.pagination) {
            params.offset = this.offset;
            params.limit = this.limit;
        }
        return params;
    }
    /**
     * @param {?} column
     * @return {?}
     */
    _sortColumn(column) {
        if (column.sortable) {
            let /** @type {?} */ ascending = this.sortBy === column.property ? !this.sortAsc : true;
            this.sort(column.property, ascending);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    _onSelectAllChanged(value) {
        this.rows.toArray().forEach(row => row.selected = value);
    }
    /**
     * @param {?} columnElement
     * @param {?} dx
     * @return {?}
     */
    _isResizeInLimit(columnElement, dx) {
        /* This is needed because CSS min-width didn't work on table-layout: fixed.
             Without the limits, resizing can make the next column disappear completely,
             and even increase the table width. The current implementation suffers from the fact,
             that offsetWidth sometimes contains out-of-date values. */
        return !((dx < 0 && (columnElement.offsetWidth + dx) <= this.resizeLimit) ||
            !columnElement.nextElementSibling || // resizing doesn't make sense for the last visible column
            // resizing doesn't make sense for the last visible column
            (dx >= 0 && ((/** @type {?} */ (columnElement.nextElementSibling)).offsetWidth + dx) <= this.resizeLimit));
    }
}
DataTable$$1.decorators = [
    { type: Component, args: [{
                selector: 'data-table',
                template: `<div class="data-table-wrapper">
  <data-table-title *ngIf="title"></data-table-title>

  <div class="data-table-box">
    <table class="table table-condensed data-table">
      <thead>
      <tr>
        <th [hide]="!expandColumnVisible" class="expand-column-header">
        <th [hide]="!indexColumnVisible" class="index-column-header">
          <span [textContent]="indexColumnHeader"></span>
        </th>
        <th [hide]="!selectColumnVisible" class="select-column-header">
          <input [hide]="!multiSelect" type="checkbox" [(ngModel)]="selectAllCheckbox"/>
        </th>
        <th *ngFor="let column of columns" #th [hide]="!column.visible" (click)="headerClicked(column, $event)"
            [class.sortable]="column.sortable" [class.resizable]="column.resizable"
            [ngClass]="column.styleClassObject" class="column-header" [style.width]="column.width | px">
          <span *ngIf="!column.headerTemplate" [textContent]="column.header"></span>
          <ng-container *ngIf="column.headerTemplate" [ngTemplateOutlet]="column.headerTemplate"
                [ngTemplateOutletContext]="{column: column}"></ng-container>
          <span class="column-sort-icon" *ngIf="column.sortable">
            <i class="fa fa-sort column-sortable-icon" [hide]="column.property === sortBy"></i>
            <span [hide]="column.property !== sortBy">
              <i class="fa fa-sort-asc" [hide]="sortAsc"></i>
              <i class="fa fa-sort-desc" [hide]="!sortAsc"></i>
            </span>
          </span>
          <span *ngIf="column.resizable" class="column-resize-handle"
                (mousedown)="resizeColumnStart($event, column, th)"></span>
        </th>
      </tr>
      </thead>
      <tbody *ngFor="let item of items; let index=index" class="data-table-row-wrapper"
             dataTableRow #row [item]="item" [index]="index" (selectedChange)="onRowSelectChanged(row)">
      </tbody>
      <tbody class="substitute-rows" *ngIf="pagination && substituteRows">
      <tr *ngFor="let item of substituteItems, let index = index"
          [class.row-odd]="(index + items.length) % 2 === 0"
          [class.row-even]="(index + items.length) % 2 === 1">
        <td [hide]="!expandColumnVisible"></td>
        <td [hide]="!indexColumnVisible">&nbsp;</td>
        <td [hide]="!selectColumnVisible"></td>
        <td *ngFor="let column of columns" [hide]="!column.visible">
      </tr>
      </tbody>
    </table>
    <div class="loading-cover" *ngIf="showReloading && reloading"></div>
  </div>

  <data-table-pagination *ngIf="pagination"></data-table-pagination>
</div>
`,
                styles: [`:host /deep/ .data-table.table>tbody+tbody{border-top:none}:host /deep/ .data-table.table td{vertical-align:middle}:host /deep/ .data-table>tbody>tr>td,:host /deep/ .data-table>thead>tr>th{overflow:hidden}:host /deep/ .row-odd{background-color:#f6f6f6}.data-table .substitute-rows>tr:hover,:host /deep/ .data-table .data-table-row:hover{background-color:#ececec}.data-table{box-shadow:0 0 15px #ececec;table-layout:fixed}.column-header{position:relative}.expand-column-header{width:50px}.select-column-header{width:50px;text-align:center}.index-column-header{width:40px}.column-header.sortable{cursor:pointer}.column-header .column-sort-icon{float:right}.column-header.resizable .column-sort-icon{margin-right:8px}.column-header .column-sort-icon .column-sortable-icon{color:#d3d3d3}.column-header .column-resize-handle{position:absolute;top:0;right:0;margin:0;padding:0;width:8px;height:100%;cursor:col-resize}.data-table-box{position:relative}.loading-cover{position:absolute;width:100%;height:100%;background-color:rgba(255,255,255,.3);top:0}`]
            },] },
];
DataTable$$1.propDecorators = {
    itemCount: [{ type: Input }],
    pagination: [{ type: Input }],
    indexColumn: [{ type: Input }],
    indexColumnHeader: [{ type: Input }],
    rowColors: [{ type: Input }],
    rowTooltip: [{ type: Input }],
    selectColumn: [{ type: Input }],
    multiSelect: [{ type: Input }],
    substituteRows: [{ type: Input }],
    expandableRows: [{ type: Input }],
    translations: [{ type: Input }],
    selectOnRowClick: [{ type: Input }],
    autoReload: [{ type: Input }],
    showReloading: [{ type: Input }],
    rowClick: [{ type: Output }],
    rowExpand: [{ type: Output }],
    rowDoubleClick: [{ type: Output }],
    headerClick: [{ type: Output }],
    cellClick: [{ type: Output }],
    reload: [{ type: Output }],
    title: [{ type: ContentChild, args: [forwardRef(() => DataTableTitle),] }],
    columns: [{ type: ContentChildren, args: [DataTableColumn,] }],
    rows: [{ type: ViewChildren, args: [DataTableRow$$1,] }],
    expandTemplate: [{ type: ContentChild, args: ['expandTemplate',] }],
    items: [{ type: Input }],
    sortBy: [{ type: Input }],
    sortAsc: [{ type: Input }],
    offset: [{ type: Input }],
    limit: [{ type: Input }],
    page: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @template T
 */
class DataTableTitleComponent {
    /**
     * @param {?} dataTable
     */
    constructor(dataTable) {
        this.dataTable = dataTable;
        this.columnSelectorOpen = false;
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    _closeSelector($event) {
        this.columnSelectorOpen = false;
    }
}
DataTableTitleComponent.decorators = [
    { type: Component, args: [{
                selector: 'data-table-title',
                template: `<div class="navbar">
  <h4 class="title" [textContent]="dataTable.title.title"></h4>
  <ng-container *ngIf="dataTable.title.titleTemplate" [ngTemplateOutlet]="dataTable.title.titleTemplate"
                [ngTemplateOutletContext]="{items: dataTable.items}">
  </ng-container>
  <div *ngIf="dataTable.title.controls">
    <button type="button" class="btn btn-default btn-sm refresh-button" (click)="dataTable.reloadItems()">
      <i class="fa fa-refresh"></i>
    </button>
    <button type="button" class="btn btn-default btn-sm column-selector-button" [class.active]="columnSelectorOpen"
            (click)="columnSelectorOpen = !columnSelectorOpen; $event.stopPropagation()">
      <i class="fa fa-list"></i>
    </button>
    <div class="column-selector-wrapper" (click)="$event.stopPropagation()">
      <div *ngIf="columnSelectorOpen" class="column-selector-box card">
        <div *ngIf="dataTable.expandableRows" class="column-selector-fixed-column checkbox">
          <label>
            <input type="checkbox" [(ngModel)]="dataTable.expandColumnVisible"/>
            <span>{{dataTable.translations.expandColumn}}</span>
          </label>
        </div>
        <div *ngIf="dataTable.indexColumn" class="column-selector-fixed-column checkbox">
          <label>
            <input type="checkbox" [(ngModel)]="dataTable.indexColumnVisible"/>
            <span>{{dataTable.translations.indexColumn}}</span>
          </label>
        </div>
        <div *ngIf="dataTable.selectColumn" class="column-selector-fixed-column checkbox">
          <label>
            <input type="checkbox" [(ngModel)]="dataTable.selectColumnVisible"/>
            <span>{{dataTable.translations.selectColumn}}</span>
          </label>
        </div>
        <div *ngFor="let column of dataTable.columns" class="column-selector-column checkbox">
          <label>
            <input type="checkbox" [(ngModel)]="column.visible"/>
            <span [textContent]="column.header"></span>
          </label>
        </div>
      </div>
    </div>
  </div>
</div>
`,
                styles: [`.navbar{padding:10px 0}.navbar .title{margin:5px 0 0 5px}.column-selector-wrapper{position:relative}.column-selector-wrapper .column-selector-box{box-shadow:0 0 10px #d3d3d3;width:150px;padding:10px;position:absolute;right:0;top:1px;z-index:1060}.column-selector-wrapper .column-selector-box .checkbox{margin-bottom:4px}.column-selector-wrapper .column-selector-box .column-selector-fixed-column{font-style:italic}`]
            },] },
];
/** @nocollapse */
DataTableTitleComponent.ctorParameters = () => [
    { type: DataTable$$1, decorators: [{ type: Inject, args: [forwardRef(() => DataTable$$1),] }] }
];
DataTableTitleComponent.propDecorators = {
    _closeSelector: [{ type: HostListener, args: ['document:click', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class DataTableTitle {
    constructor() {
        this.title = '';
        this.controls = true;
    }
}
DataTableTitle.decorators = [
    { type: Directive, args: [{
                selector: 'data-table-title'
            },] },
];
DataTableTitle.propDecorators = {
    title: [{ type: Input }],
    titleTemplate: [{ type: ContentChild, args: ['titleTemplate',] }],
    controls: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} obj
 * @return {?}
 */
function isBlank(obj) {
    return obj === undefined || obj === null;
}
class HideDirective {
    /**
     * @param {?} _elementRef
     * @param {?} _renderer
     */
    constructor(_elementRef, _renderer) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this._prevCondition = null;
    }
    /**
     * @param {?} newCondition
     * @return {?}
     */
    set hide(newCondition) {
        this.initDisplayStyle();
        if (newCondition && (isBlank(this._prevCondition) || !this._prevCondition)) {
            this._prevCondition = true;
            this._renderer.setElementStyle(this._elementRef.nativeElement, 'display', 'none');
        }
        else if (!newCondition && (isBlank(this._prevCondition) || this._prevCondition)) {
            this._prevCondition = false;
            this._renderer.setElementStyle(this._elementRef.nativeElement, 'display', this._displayStyle);
        }
    }
    /**
     * @return {?}
     */
    initDisplayStyle() {
        if (this._displayStyle === undefined) {
            let /** @type {?} */ displayStyle = this._elementRef.nativeElement.style.display;
            if (displayStyle && displayStyle !== 'none') {
                this._displayStyle = displayStyle;
            }
        }
    }
}
HideDirective.decorators = [
    { type: Directive, args: [{ selector: '[hide]' },] },
];
/** @nocollapse */
HideDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer }
];
HideDirective.propDecorators = {
    hide: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class MinPipe {
    /**
     * @param {?} value
     * @param {...?} args
     * @return {?}
     */
    transform(value, ...args) {
        return Math.min.apply(null, value);
    }
}
MinPipe.decorators = [
    { type: Pipe, args: [{
                name: 'min'
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class PxPipe {
    /**
     * @param {?} value
     * @param {...?} args
     * @return {?}
     */
    transform(value, ...args) {
        if (value) {
            return Number(value) >= 0 ? `${value}px` : value;
        }
    }
}
PxPipe.decorators = [
    { type: Pipe, args: [{
                name: 'px'
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @template T
 */
class DataTableResource {
    /**
     * @param {?} items
     */
    constructor(items) {
        this.items = items;
    }
    /**
     * @param {?} params
     * @param {?=} filter
     * @return {?}
     */
    query(params, filter) {
        let /** @type {?} */ result = [];
        if (filter) {
            result = this.items.filter(filter);
        }
        else {
            result = this.items.slice(); // shallow copy to use for sorting instead of changing the original
        }
        if (params.sortBy) {
            result.sort((a, b) => {
                if (typeof a[params.sortBy] === 'string') {
                    return a[params.sortBy].localeCompare(b[params.sortBy]);
                }
                else {
                    return a[params.sortBy] - b[params.sortBy];
                }
            });
            if (params.sortAsc === false) {
                result.reverse();
            }
        }
        if (params.offset !== undefined) {
            if (params.limit === undefined) {
                result = result.slice(params.offset, result.length);
            }
            else {
                result = result.slice(params.offset, params.offset + params.limit);
            }
        }
        return new Promise((resolve, reject) => {
            setTimeout(() => resolve(result));
        });
    }
    /**
     * @return {?}
     */
    count() {
        return new Promise((resolve, reject) => {
            setTimeout(() => resolve(this.items.length));
        });
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class DataTableModule {
}
DataTableModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule
                ],
                declarations: [
                    DataTable$$1,
                    DataTableColumn,
                    DataTableTitle,
                    DataTableRow$$1,
                    DataTablePagination$$1,
                    DataTableTitleComponent,
                    PxPipe,
                    HideDirective,
                    MinPipe
                ],
                exports: [DataTable$$1, DataTableColumn, DataTableTitle, DataTablePagination$$1]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { DataTable$$1 as DataTable, DataTableColumn, DataTableRow$$1 as DataTableRow, DataTableTitle, DataTablePagination$$1 as DataTablePagination, DataTableModule, defaultTranslations, DataTableResource, DataTableTitleComponent as ɵa, HideDirective as ɵc, MinPipe as ɵd, PxPipe as ɵb };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWRhdGF0YWJsZS1ib290c3RyYXA0LmpzLm1hcCIsInNvdXJjZXMiOlsibmc6Ly9uZ3gtZGF0YXRhYmxlLWJvb3RzdHJhcDQvY29tcG9uZW50cy9jb2x1bW4vY29sdW1uLmRpcmVjdGl2ZS50cyIsIm5nOi8vbmd4LWRhdGF0YWJsZS1ib290c3RyYXA0L2NvbXBvbmVudHMvcGFnaW5hdGlvbi9wYWdpbmF0aW9uLmNvbXBvbmVudC50cyIsIm5nOi8vbmd4LWRhdGF0YWJsZS1ib290c3RyYXA0L2NvbXBvbmVudHMvcm93L3Jvdy5jb21wb25lbnQudHMiLCJuZzovL25neC1kYXRhdGFibGUtYm9vdHN0cmFwNC91dGlscy9kcmFnLnRzIiwibmc6Ly9uZ3gtZGF0YXRhYmxlLWJvb3RzdHJhcDQvY29tcG9uZW50cy90eXBlcy50cyIsIm5nOi8vbmd4LWRhdGF0YWJsZS1ib290c3RyYXA0L2NvbXBvbmVudHMvdGFibGUvdGFibGUuY29tcG9uZW50LnRzIiwibmc6Ly9uZ3gtZGF0YXRhYmxlLWJvb3RzdHJhcDQvY29tcG9uZW50cy90aXRsZS90aXRsZS5jb21wb25lbnQudHMiLCJuZzovL25neC1kYXRhdGFibGUtYm9vdHN0cmFwNC9jb21wb25lbnRzL3RpdGxlL3RpdGxlLmRpcmVjdGl2ZS50cyIsIm5nOi8vbmd4LWRhdGF0YWJsZS1ib290c3RyYXA0L3V0aWxzL2hpZGUuZGlyZWN0aXZlLnRzIiwibmc6Ly9uZ3gtZGF0YXRhYmxlLWJvb3RzdHJhcDQvdXRpbHMvbWluLnBpcGUudHMiLCJuZzovL25neC1kYXRhdGFibGUtYm9vdHN0cmFwNC91dGlscy9weC5waXBlLnRzIiwibmc6Ly9uZ3gtZGF0YXRhYmxlLWJvb3RzdHJhcDQvdG9vbHMvZGF0YS10YWJsZS1yZXNvdXJjZS50cyIsIm5nOi8vbmd4LWRhdGF0YWJsZS1ib290c3RyYXA0L2luZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Q29udGVudENoaWxkLCBEaXJlY3RpdmUsIElucHV0LCBPbkluaXQsIFRlbXBsYXRlUmVmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RGF0YVRhYmxlUm93fSBmcm9tICcuLi8uLi8nO1xuaW1wb3J0IHtDZWxsQ2FsbGJhY2t9IGZyb20gJy4uL3R5cGVzJztcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnZGF0YS10YWJsZS1jb2x1bW4nXG59KVxuZXhwb3J0IGNsYXNzIERhdGFUYWJsZUNvbHVtbjxUPiBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgLy8gZm9yIFtuZ0NsYXNzXVxuICBzdHlsZUNsYXNzT2JqZWN0ID0ge307XG5cbiAgLy8gaW5pdDpcbiAgQElucHV0KClcbiAgaGVhZGVyOiBzdHJpbmc7XG4gIEBJbnB1dCgpXG4gIHNvcnRhYmxlID0gZmFsc2U7XG4gIEBJbnB1dCgpXG4gIHJlc2l6YWJsZSA9IGZhbHNlO1xuICBASW5wdXQoKVxuICBwcm9wZXJ0eTogc3RyaW5nO1xuICBASW5wdXQoKVxuICBzdHlsZUNsYXNzOiBzdHJpbmc7XG4gIEBJbnB1dCgpXG4gIGNlbGxDb2xvcnM6IENlbGxDYWxsYmFjazxUPjtcbiAgQElucHV0KClcbiAgd2lkdGg6IG51bWJlciB8IHN0cmluZztcbiAgQElucHV0KClcbiAgdmlzaWJsZSA9IHRydWU7XG5cbiAgQENvbnRlbnRDaGlsZCgnY2VsbFRlbXBsYXRlJylcbiAgY2VsbFRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICBAQ29udGVudENoaWxkKCdoZWFkZXJUZW1wbGF0ZScpXG4gIGhlYWRlclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gIGdldENlbGxDb2xvcihyb3c6IERhdGFUYWJsZVJvdzxUPiwgaW5kZXg6IG51bWJlcikge1xuICAgIGlmICh0aGlzLmNlbGxDb2xvcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuICg8Q2VsbENhbGxiYWNrPFQ+PnRoaXMuY2VsbENvbG9ycykocm93Lml0ZW0sIHJvdywgdGhpcywgaW5kZXgpO1xuICAgIH1cbiAgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMuX2luaXRDZWxsQ2xhc3MoKTtcbiAgfVxuXG4gIHByaXZhdGUgX2luaXRDZWxsQ2xhc3MoKSB7XG4gICAgaWYgKCF0aGlzLnN0eWxlQ2xhc3MgJiYgdGhpcy5wcm9wZXJ0eSkge1xuICAgICAgaWYgKC9eW2EtekEtWjAtOV9dKyQvLnRlc3QodGhpcy5wcm9wZXJ0eSkpIHtcbiAgICAgICAgdGhpcy5zdHlsZUNsYXNzID0gJ2NvbHVtbi0nICsgdGhpcy5wcm9wZXJ0eTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3R5bGVDbGFzcyA9ICdjb2x1bW4tJyArIHRoaXMucHJvcGVydHkucmVwbGFjZSgvW15hLXpBLVowLTlfXS9nLCAnJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3R5bGVDbGFzcyAhPSBudWxsKSB7XG4gICAgICB0aGlzLnN0eWxlQ2xhc3NPYmplY3QgPSB7XG4gICAgICAgIFt0aGlzLnN0eWxlQ2xhc3NdOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHtDb21wb25lbnQsIGZvcndhcmRSZWYsIEluamVjdH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0RhdGFUYWJsZX0gZnJvbSAnLi4vLi4vJztcblxuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdkYXRhLXRhYmxlLXBhZ2luYXRpb24nLFxuICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJuYXZiYXIgcC0wIHBhZ2luYXRpb24tY29tcG9uZW50XCI+XG4gIDxkaXY+XG4gICAge3tkYXRhVGFibGUudHJhbnNsYXRpb25zLnBhZ2luYXRpb25SYW5nZX19OiZuYnNwO3t7ZGF0YVRhYmxlLm9mZnNldCA8IDAgPyAwIDogZGF0YVRhYmxlLm9mZnNldCArIDF9fSZuYnNwOy1cbiAgICB7e1tkYXRhVGFibGUub2Zmc2V0ICsgZGF0YVRhYmxlLmxpbWl0ICwgZGF0YVRhYmxlLml0ZW1Db3VudF0gfCBtaW59fSZuYnNwOy8mbmJzcDt7e2RhdGFUYWJsZS5pdGVtQ291bnR9fVxuICA8L2Rpdj5cbiAgPHVsIGNsYXNzPVwibmF2IGp1c3RpZnktY29udGVudC1lbmRcIj5cbiAgICA8bGkgY2xhc3M9XCJuYXYtaXRlbSBwYWdpbmF0aW9uLWxpbWl0XCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXBcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwLXByZXBlbmRcIj5cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cImlucHV0LWdyb3VwLXRleHRcIj57e2RhdGFUYWJsZS50cmFuc2xhdGlvbnMucGFnaW5hdGlvbkxpbWl0fX06PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGlucHV0ICNsaW1pdElucHV0IHR5cGU9XCJudW1iZXJcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIG1pbj1cIjFcIiBzdGVwPVwiMVwiXG4gICAgICAgICAgICAgICBbbmdNb2RlbF09XCJsaW1pdFwiIChibHVyKT1cImxpbWl0ID0gbGltaXRJbnB1dC52YWx1ZVwiXG4gICAgICAgICAgICAgICAoa2V5dXAuZW50ZXIpPVwibGltaXQgPSBsaW1pdElucHV0LnZhbHVlXCJcbiAgICAgICAgICAgICAgIChrZXl1cC5lc2MpPVwibGltaXRJbnB1dC52YWx1ZSA9IGxpbWl0XCJcbiAgICAgICAgICAgICAgIChrZXlwcmVzcyk9XCJrZXlQcmVzcygkZXZlbnQpXCIvPlxuICAgICAgPC9kaXY+XG4gICAgPC9saT5cbiAgICA8bGkgY2xhc3M9XCJuYXYtaXRlbVwiPlxuICAgICAgPGJ1dHRvbiBbZGlzYWJsZWRdPVwiZGF0YVRhYmxlLm9mZnNldCA8PSAwXCIgKGNsaWNrKT1cInBhZ2VGaXJzdCgpXCIgY2xhc3M9XCJidG4gYnRuLWRlZmF1bHRcIj4mbGFxdW87PC9idXR0b24+XG4gICAgICA8YnV0dG9uIFtkaXNhYmxlZF09XCJkYXRhVGFibGUub2Zmc2V0IDw9IDBcIiAoY2xpY2spPVwicGFnZUJhY2soKVwiIGNsYXNzPVwiYnRuIGJ0bi1kZWZhdWx0XCI+JmxzYXF1bzs8L2J1dHRvbj5cbiAgICAgIDxkaXYgY2xhc3M9XCJkLWlubGluZS1ibG9ja1wiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXBcIj5cbiAgICAgICAgICA8aW5wdXQgI3BhZ2VJbnB1dCB0eXBlPVwibnVtYmVyXCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBtaW49XCIxXCIgc3RlcD1cIjFcIiBtYXg9XCJ7e21heFBhZ2V9fVwiXG4gICAgICAgICAgICAgICAgIFtuZ01vZGVsXT1cInBhZ2VcIiAoYmx1cik9XCJwYWdlID0gcGFnZUlucHV0LnZhbHVlXCJcbiAgICAgICAgICAgICAgICAgKGtleXVwLmVudGVyKT1cInBhZ2UgPSBwYWdlSW5wdXQudmFsdWVcIiAoa2V5dXAuZXNjKT1cInBhZ2VJbnB1dC52YWx1ZSA9IHBhZ2VcIlxuICAgICAgICAgICAgICAgICAoa2V5cHJlc3MpPVwia2V5UHJlc3MoJGV2ZW50KVwiLz5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXAtYXBwZW5kXCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImlucHV0LWdyb3VwLXRleHRcIj4vJm5ic3A7e3tkYXRhVGFibGUubGFzdFBhZ2V9fTwvc3Bhbj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxidXR0b24gW2Rpc2FibGVkXT1cIihkYXRhVGFibGUub2Zmc2V0ICsgZGF0YVRhYmxlLmxpbWl0KSA+PSBkYXRhVGFibGUuaXRlbUNvdW50XCIgKGNsaWNrKT1cInBhZ2VGb3J3YXJkKClcIlxuICAgICAgICAgICAgICBjbGFzcz1cImJ0biBidG4tZGVmYXVsdFwiPiZyc2FxdW87XG4gICAgICA8L2J1dHRvbj5cbiAgICAgIDxidXR0b24gW2Rpc2FibGVkXT1cIihkYXRhVGFibGUub2Zmc2V0ICsgZGF0YVRhYmxlLmxpbWl0KSA+PSBkYXRhVGFibGUuaXRlbUNvdW50XCIgKGNsaWNrKT1cInBhZ2VMYXN0KClcIlxuICAgICAgICAgICAgICBjbGFzcz1cImJ0biBidG4tZGVmYXVsdFwiPiZyYXF1bztcbiAgICAgIDwvYnV0dG9uPlxuICAgIDwvbGk+XG4gIDwvdWw+XG48L2Rpdj5cbmAsXG4gIHN0eWxlczogW2AucGFnaW5hdGlvbi1jb21wb25lbnQgLnBhZ2luYXRpb24tbGltaXR7bWFyZ2luLXJpZ2h0OjFyZW19LnBhZ2luYXRpb24tY29tcG9uZW50IC5wYWdpbmF0aW9uLWxpbWl0IGlucHV0e3dpZHRoOjc1cHh9LnBhZ2luYXRpb24tY29tcG9uZW50IC5idG57bWFyZ2luLXRvcDotM3B4fWBdXG59KVxuZXhwb3J0IGNsYXNzIERhdGFUYWJsZVBhZ2luYXRpb248VD4ge1xuXG4gIGNvbnN0cnVjdG9yKEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBEYXRhVGFibGUpKSBwdWJsaWMgZGF0YVRhYmxlOiBEYXRhVGFibGU8VD4pIHtcbiAgfVxuXG4gIGdldCBtYXhQYWdlKCkge1xuICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5kYXRhVGFibGUuaXRlbUNvdW50IC8gdGhpcy5kYXRhVGFibGUubGltaXQpO1xuICB9XG5cbiAgZ2V0IGxpbWl0KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGFUYWJsZS5saW1pdDtcbiAgfVxuXG4gIHNldCBsaW1pdCh2YWx1ZSkge1xuICAgIGlmIChOdW1iZXIodmFsdWUpID4gMCkge1xuICAgICAgdGhpcy5kYXRhVGFibGUubGltaXQgPSBNYXRoLmZsb29yKCt2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IHBhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVRhYmxlLnBhZ2U7XG4gIH1cblxuICBzZXQgcGFnZSh2YWx1ZSkge1xuICAgIGlmIChOdW1iZXIodmFsdWUpID4gMCkge1xuICAgICAgdGhpcy5kYXRhVGFibGUucGFnZSA9IE1hdGguZmxvb3IoK3ZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBwYWdlQmFjaygpIHtcbiAgICB0aGlzLmRhdGFUYWJsZS5vZmZzZXQgLT0gTWF0aC5taW4odGhpcy5kYXRhVGFibGUubGltaXQsIHRoaXMuZGF0YVRhYmxlLm9mZnNldCk7XG4gIH1cblxuICBwYWdlRm9yd2FyZCgpIHtcbiAgICB0aGlzLmRhdGFUYWJsZS5vZmZzZXQgKz0gdGhpcy5kYXRhVGFibGUubGltaXQ7XG4gIH1cblxuICBwYWdlRmlyc3QoKSB7XG4gICAgdGhpcy5kYXRhVGFibGUub2Zmc2V0ID0gMDtcbiAgfVxuXG4gIHBhZ2VMYXN0KCkge1xuICAgIHRoaXMuZGF0YVRhYmxlLm9mZnNldCA9ICh0aGlzLm1heFBhZ2UgLSAxKSAqIHRoaXMuZGF0YVRhYmxlLmxpbWl0O1xuICB9XG5cbiAga2V5UHJlc3MoZXZlbnQ6IGFueSkge1xuICAgIGxldCBpbnB1dENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGV2ZW50LmNoYXJDb2RlKTtcbiAgICBpZiAoIShOdW1iZXIoaW5wdXRDaGFyKSA+PSAwKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7Q29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIGZvcndhcmRSZWYsIEluamVjdCwgSW5wdXQsIE9uRGVzdHJveSwgT3V0cHV0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RGF0YVRhYmxlfSBmcm9tICcuLi8uLi8nO1xuXG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ1tkYXRhVGFibGVSb3ddJyxcbiAgdGVtcGxhdGU6IGA8dHIgY2xhc3M9XCJkYXRhLXRhYmxlLXJvd1wiXG4gICAgW3RpdGxlXT1cImdldFRvb2x0aXAoKVwiXG4gICAgW3N0eWxlLmJhY2tncm91bmQtY29sb3JdPVwiZGF0YVRhYmxlLmdldFJvd0NvbG9yKGl0ZW0sIGluZGV4LCBfdGhpcylcIlxuICAgIFtjbGFzcy5yb3ctb2RkXT1cImluZGV4ICUgMiA9PT0gMFwiXG4gICAgW2NsYXNzLnJvdy1ldmVuXT1cImluZGV4ICUgMiA9PT0gMVwiXG4gICAgW2NsYXNzLnNlbGVjdGVkXT1cInNlbGVjdGVkXCJcbiAgICBbY2xhc3MuY2xpY2thYmxlXT1cImRhdGFUYWJsZS5zZWxlY3RPblJvd0NsaWNrXCJcbiAgICAoZGJsY2xpY2spPVwiZGF0YVRhYmxlLnJvd0RvdWJsZUNsaWNrZWQoX3RoaXMsICRldmVudClcIlxuICAgIChjbGljayk9XCJkYXRhVGFibGUucm93Q2xpY2tlZChfdGhpcywgJGV2ZW50KVwiPlxuICA8dGQgW2hpZGVdPVwiIWRhdGFUYWJsZS5leHBhbmRDb2x1bW5WaXNpYmxlXCIgY2xhc3M9XCJyb3ctZXhwYW5kLWJ1dHRvblwiXG4gICAgICAoY2xpY2spPVwiZXhwYW5kZWQgPSAhZXhwYW5kZWQ7ICRldmVudC5zdG9wUHJvcGFnYXRpb24oKTsgZGF0YVRhYmxlLnJvd0V4cGFuZGVkKF90aGlzLCAkZXZlbnQpXCI+XG4gICAgPHNwYW4gY2xhc3M9XCJmYSBmYS1hcnJvdy1jaXJjbGUtby1yaWdodFwiIFtoaWRlXT1cImV4cGFuZGVkXCI+PC9zcGFuPlxuICAgIDxzcGFuIGNsYXNzPVwiZmEgZmEtYXJyb3ctY2lyY2xlLW8tZG93blwiIFtoaWRlXT1cIiFleHBhbmRlZFwiPjwvc3Bhbj5cbiAgPC90ZD5cbiAgPHRkIFtoaWRlXT1cIiFkYXRhVGFibGUuaW5kZXhDb2x1bW5WaXNpYmxlXCIgY2xhc3M9XCJpbmRleC1jb2x1bW5cIiBbdGV4dENvbnRlbnRdPVwiZGlzcGxheUluZGV4XCI+PC90ZD5cbiAgPHRkIFtoaWRlXT1cIiFkYXRhVGFibGUuc2VsZWN0Q29sdW1uVmlzaWJsZVwiIGNsYXNzPVwic2VsZWN0LWNvbHVtblwiPlxuICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBbKG5nTW9kZWwpXT1cInNlbGVjdGVkXCIvPlxuICA8L3RkPlxuICA8dGQgKm5nRm9yPVwibGV0IGNvbHVtbiBvZiBkYXRhVGFibGUuY29sdW1uc1wiIFtoaWRlXT1cIiFjb2x1bW4udmlzaWJsZVwiIFtuZ0NsYXNzXT1cImNvbHVtbi5zdHlsZUNsYXNzT2JqZWN0XCJcbiAgICAgIGNsYXNzPVwiZGF0YS1jb2x1bW5cIlxuICAgICAgW3N0eWxlLmJhY2tncm91bmQtY29sb3JdPVwiY29sdW1uLmdldENlbGxDb2xvcihfdGhpcywgaW5kZXgpXCJcbiAgICAgIChjbGljayk9XCJkYXRhVGFibGUuY2VsbENsaWNrZWQoY29sdW1uLCBfdGhpcywgJGV2ZW50KVwiPlxuICAgIDxkaXYgKm5nSWY9XCIhY29sdW1uLmNlbGxUZW1wbGF0ZVwiIFt0ZXh0Q29udGVudF09XCJpdGVtW2NvbHVtbi5wcm9wZXJ0eV1cIj48L2Rpdj5cbiAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiY29sdW1uLmNlbGxUZW1wbGF0ZVwiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImNvbHVtbi5jZWxsVGVtcGxhdGVcIlxuICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cIntjb2x1bW46IGNvbHVtbiwgcm93OiBfdGhpcywgaXRlbTogaXRlbX1cIj48L25nLWNvbnRhaW5lcj5cbiAgPC90ZD5cbjwvdHI+XG48dHIgKm5nSWY9XCJkYXRhVGFibGUuZXhwYW5kYWJsZVJvd3NcIiBbaGlkZV09XCIhZXhwYW5kZWRcIiBjbGFzcz1cInJvdy1leHBhbnNpb25cIj5cbiAgPHRkIFthdHRyLmNvbHNwYW5dPVwiZGF0YVRhYmxlLmNvbHVtbkNvdW50XCI+XG4gICAgPG5nLWNvbnRhaW5lciBbbmdUZW1wbGF0ZU91dGxldF09XCJkYXRhVGFibGUuZXhwYW5kVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cIntyb3c6IF90aGlzLCBpdGVtOiBpdGVtfVwiPjwvbmctY29udGFpbmVyPlxuICA8L3RkPlxuPC90cj5cbmAsXG4gIHN0eWxlczogW2Auc2VsZWN0LWNvbHVtbnt0ZXh0LWFsaWduOmNlbnRlcn0ucm93LWV4cGFuZC1idXR0b257Y3Vyc29yOnBvaW50ZXI7dGV4dC1hbGlnbjpjZW50ZXJ9LmNsaWNrYWJsZXtjdXJzb3I6cG9pbnRlcn1gXVxufSlcbmV4cG9ydCBjbGFzcyBEYXRhVGFibGVSb3c8VD4gaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gIC8vIHJvdyBzZWxlY3Rpb246XG4gIHByaXZhdGUgX3NlbGVjdGVkOiBib29sZWFuO1xuICBleHBhbmRlZDogYm9vbGVhbjtcblxuICBASW5wdXQoKVxuICBpdGVtOiBUO1xuICBASW5wdXQoKVxuICBpbmRleDogbnVtYmVyO1xuXG4gIEBPdXRwdXQoKVxuICBzZWxlY3RlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAvLyBGSVhNRSBpcyB0aGVyZSBubyB0ZW1wbGF0ZSBrZXl3b3JkIGZvciB0aGlzIGluIGFuZ3VsYXIgMj9cbiAgcHVibGljIF90aGlzID0gdGhpcztcblxuICBjb25zdHJ1Y3RvcihASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gRGF0YVRhYmxlKSkgcHVibGljIGRhdGFUYWJsZTogRGF0YVRhYmxlPFQ+KSB7XG4gIH1cblxuICBnZXQgc2VsZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkO1xuICB9XG5cbiAgc2V0IHNlbGVjdGVkKHNlbGVjdGVkKSB7XG4gICAgdGhpcy5fc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICB0aGlzLnNlbGVjdGVkQ2hhbmdlLmVtaXQoc2VsZWN0ZWQpO1xuICB9XG5cbiAgLy8gb3RoZXI6XG4gIGdldCBkaXNwbGF5SW5kZXgoKSB7XG4gICAgaWYgKHRoaXMuZGF0YVRhYmxlLnBhZ2luYXRpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGFUYWJsZS5kaXNwbGF5UGFyYW1zLm9mZnNldCArIHRoaXMuaW5kZXggKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmRleCArIDE7XG4gICAgfVxuICB9XG5cbiAgZ2V0VG9vbHRpcCgpIHtcbiAgICBpZiAodGhpcy5kYXRhVGFibGUucm93VG9vbHRpcCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YVRhYmxlLnJvd1Rvb2x0aXAodGhpcy5pdGVtLCB0aGlzLCB0aGlzLmluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICB9XG59XG4iLCJleHBvcnQgdHlwZSBNb3ZlSGFuZGxlciA9IChldmVudDogTW91c2VFdmVudCwgZHg6IG51bWJlciwgZHk6IG51bWJlciwgeDogbnVtYmVyLCB5OiBudW1iZXIpID0+IHZvaWQ7XG5leHBvcnQgdHlwZSBVcEhhbmRsZXIgPSAoZXZlbnQ6IE1vdXNlRXZlbnQsIHg6IG51bWJlciwgeTogbnVtYmVyLCBtb3ZlZDogYm9vbGVhbikgPT4gdm9pZDtcblxuZXhwb3J0IGZ1bmN0aW9uIGRyYWcoZXZlbnQ6IE1vdXNlRXZlbnQsIHttb3ZlLCB1cH06IHsgbW92ZTogTW92ZUhhbmRsZXIsIHVwPzogVXBIYW5kbGVyIH0pIHtcblxuICBsZXQgc3RhcnRYID0gZXZlbnQucGFnZVg7XG4gIGxldCBzdGFydFkgPSBldmVudC5wYWdlWTtcbiAgbGV0IHggPSBzdGFydFg7XG4gIGxldCB5ID0gc3RhcnRZO1xuICBsZXQgbW92ZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBtb3VzZU1vdmVIYW5kbGVyKGU6IE1vdXNlRXZlbnQpIHtcbiAgICBsZXQgZHggPSBlLnBhZ2VYIC0geDtcbiAgICBsZXQgZHkgPSBlLnBhZ2VZIC0geTtcbiAgICB4ID0gZS5wYWdlWDtcbiAgICB5ID0gZS5wYWdlWTtcbiAgICBpZiAoZHggfHwgZHkpIHtcbiAgICAgIG1vdmVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBtb3ZlKGUsIGR4LCBkeSwgeCwgeSk7XG5cbiAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIHRvIGF2b2lkIHRleHQgc2VsZWN0aW9uXG4gIH1cblxuICBmdW5jdGlvbiBtb3VzZVVwSGFuZGxlcihlOiBNb3VzZUV2ZW50KSB7XG4gICAgeCA9IGUucGFnZVg7XG4gICAgeSA9IGUucGFnZVk7XG5cbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBtb3VzZU1vdmVIYW5kbGVyKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbW91c2VVcEhhbmRsZXIpO1xuXG4gICAgaWYgKHVwKSB7XG4gICAgICB1cChlLCB4LCB5LCBtb3ZlZCk7XG4gICAgfVxuICB9XG5cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW91c2VNb3ZlSGFuZGxlcik7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBtb3VzZVVwSGFuZGxlcik7XG59XG4iLCJpbXBvcnQge0RhdGFUYWJsZUNvbHVtbn0gZnJvbSAnLi9jb2x1bW4vY29sdW1uLmRpcmVjdGl2ZSc7XG5pbXBvcnQge0RhdGFUYWJsZVJvd30gZnJvbSAnLi9yb3cvcm93LmNvbXBvbmVudCc7XG5cbmV4cG9ydCB0eXBlIFJvd0NhbGxiYWNrPFQ+ID0gKGl0ZW06IGFueSwgcm93OiBEYXRhVGFibGVSb3c8VD4sIGluZGV4OiBudW1iZXIpID0+IHN0cmluZztcbmV4cG9ydCB0eXBlIENlbGxDYWxsYmFjazxUPiA9IChpdGVtOiBhbnksIHJvdzogRGF0YVRhYmxlUm93PFQ+LCBjb2x1bW46IERhdGFUYWJsZUNvbHVtbjxUPiwgaW5kZXg6IG51bWJlcikgPT4gc3RyaW5nO1xuXG5leHBvcnQgaW50ZXJmYWNlIERhdGFUYWJsZVRyYW5zbGF0aW9ucyB7XG4gIGluZGV4Q29sdW1uOiBzdHJpbmdcbiAgc2VsZWN0Q29sdW1uOiBzdHJpbmdcbiAgZXhwYW5kQ29sdW1uOiBzdHJpbmdcbiAgcGFnaW5hdGlvbkxpbWl0OiBzdHJpbmdcbiAgcGFnaW5hdGlvblJhbmdlOiBzdHJpbmdcbn1cblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRUcmFuc2xhdGlvbnMgPSA8RGF0YVRhYmxlVHJhbnNsYXRpb25zPntcbiAgaW5kZXhDb2x1bW46ICdpbmRleCcsXG4gIHNlbGVjdENvbHVtbjogJ3NlbGVjdCcsXG4gIGV4cGFuZENvbHVtbjogJ2V4cGFuZCcsXG4gIHBhZ2luYXRpb25MaW1pdDogJ0xpbWl0JyxcbiAgcGFnaW5hdGlvblJhbmdlOiAnUmVzdWx0cydcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0YVRhYmxlUGFyYW1zIHtcbiAgb2Zmc2V0PzogbnVtYmVyXG4gIGxpbWl0PzogbnVtYmVyXG4gIHNvcnRCeT86IHN0cmluZ1xuICBzb3J0QXNjPzogYm9vbGVhblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIERhdGFUYWJsZVJvd0V2ZW50PFQ+IHtcbiAgcm93PzogRGF0YVRhYmxlUm93PFQ+XG4gIGV2ZW50PzogTW91c2VFdmVudFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIERhdGFUYWJsZUNlbGxFdmVudDxUPiB7XG4gIHJvdz86IERhdGFUYWJsZVJvdzxUPlxuICBjb2x1bW4/OiBEYXRhVGFibGVDb2x1bW48VD5cbiAgZXZlbnQ/OiBNb3VzZUV2ZW50XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0YVRhYmxlSGVhZGVyRXZlbnQ8VD4ge1xuICBjb2x1bW4/OiBEYXRhVGFibGVDb2x1bW48VD5cbiAgZXZlbnQ/OiBNb3VzZUV2ZW50XG59XG4iLCJpbXBvcnQge1xuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZCxcbiAgQ29udGVudENoaWxkcmVuLFxuICBFdmVudEVtaXR0ZXIsXG4gIGZvcndhcmRSZWYsXG4gIElucHV0LFxuICBPbkluaXQsXG4gIE91dHB1dCxcbiAgUXVlcnlMaXN0LFxuICBUZW1wbGF0ZVJlZixcbiAgVmlld0NoaWxkcmVuXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtEYXRhVGFibGVDb2x1bW4sIERhdGFUYWJsZVJvdywgRGF0YVRhYmxlVGl0bGV9IGZyb20gJy4uLy4uLyc7XG5pbXBvcnQge2RyYWd9IGZyb20gJy4uLy4uL3V0aWxzL2RyYWcnO1xuaW1wb3J0IHtcbiAgRGF0YVRhYmxlQ2VsbEV2ZW50LFxuICBEYXRhVGFibGVIZWFkZXJFdmVudCxcbiAgRGF0YVRhYmxlUGFyYW1zLFxuICBEYXRhVGFibGVSb3dFdmVudCxcbiAgRGF0YVRhYmxlVHJhbnNsYXRpb25zLFxuICBkZWZhdWx0VHJhbnNsYXRpb25zLFxuICBSb3dDYWxsYmFja1xufSBmcm9tICcuLi90eXBlcyc7XG5cblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnZGF0YS10YWJsZScsXG4gIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cImRhdGEtdGFibGUtd3JhcHBlclwiPlxuICA8ZGF0YS10YWJsZS10aXRsZSAqbmdJZj1cInRpdGxlXCI+PC9kYXRhLXRhYmxlLXRpdGxlPlxuXG4gIDxkaXYgY2xhc3M9XCJkYXRhLXRhYmxlLWJveFwiPlxuICAgIDx0YWJsZSBjbGFzcz1cInRhYmxlIHRhYmxlLWNvbmRlbnNlZCBkYXRhLXRhYmxlXCI+XG4gICAgICA8dGhlYWQ+XG4gICAgICA8dHI+XG4gICAgICAgIDx0aCBbaGlkZV09XCIhZXhwYW5kQ29sdW1uVmlzaWJsZVwiIGNsYXNzPVwiZXhwYW5kLWNvbHVtbi1oZWFkZXJcIj5cbiAgICAgICAgPHRoIFtoaWRlXT1cIiFpbmRleENvbHVtblZpc2libGVcIiBjbGFzcz1cImluZGV4LWNvbHVtbi1oZWFkZXJcIj5cbiAgICAgICAgICA8c3BhbiBbdGV4dENvbnRlbnRdPVwiaW5kZXhDb2x1bW5IZWFkZXJcIj48L3NwYW4+XG4gICAgICAgIDwvdGg+XG4gICAgICAgIDx0aCBbaGlkZV09XCIhc2VsZWN0Q29sdW1uVmlzaWJsZVwiIGNsYXNzPVwic2VsZWN0LWNvbHVtbi1oZWFkZXJcIj5cbiAgICAgICAgICA8aW5wdXQgW2hpZGVdPVwiIW11bHRpU2VsZWN0XCIgdHlwZT1cImNoZWNrYm94XCIgWyhuZ01vZGVsKV09XCJzZWxlY3RBbGxDaGVja2JveFwiLz5cbiAgICAgICAgPC90aD5cbiAgICAgICAgPHRoICpuZ0Zvcj1cImxldCBjb2x1bW4gb2YgY29sdW1uc1wiICN0aCBbaGlkZV09XCIhY29sdW1uLnZpc2libGVcIiAoY2xpY2spPVwiaGVhZGVyQ2xpY2tlZChjb2x1bW4sICRldmVudClcIlxuICAgICAgICAgICAgW2NsYXNzLnNvcnRhYmxlXT1cImNvbHVtbi5zb3J0YWJsZVwiIFtjbGFzcy5yZXNpemFibGVdPVwiY29sdW1uLnJlc2l6YWJsZVwiXG4gICAgICAgICAgICBbbmdDbGFzc109XCJjb2x1bW4uc3R5bGVDbGFzc09iamVjdFwiIGNsYXNzPVwiY29sdW1uLWhlYWRlclwiIFtzdHlsZS53aWR0aF09XCJjb2x1bW4ud2lkdGggfCBweFwiPlxuICAgICAgICAgIDxzcGFuICpuZ0lmPVwiIWNvbHVtbi5oZWFkZXJUZW1wbGF0ZVwiIFt0ZXh0Q29udGVudF09XCJjb2x1bW4uaGVhZGVyXCI+PC9zcGFuPlxuICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJjb2x1bW4uaGVhZGVyVGVtcGxhdGVcIiBbbmdUZW1wbGF0ZU91dGxldF09XCJjb2x1bW4uaGVhZGVyVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7Y29sdW1uOiBjb2x1bW59XCI+PC9uZy1jb250YWluZXI+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJjb2x1bW4tc29ydC1pY29uXCIgKm5nSWY9XCJjb2x1bW4uc29ydGFibGVcIj5cbiAgICAgICAgICAgIDxpIGNsYXNzPVwiZmEgZmEtc29ydCBjb2x1bW4tc29ydGFibGUtaWNvblwiIFtoaWRlXT1cImNvbHVtbi5wcm9wZXJ0eSA9PT0gc29ydEJ5XCI+PC9pPlxuICAgICAgICAgICAgPHNwYW4gW2hpZGVdPVwiY29sdW1uLnByb3BlcnR5ICE9PSBzb3J0QnlcIj5cbiAgICAgICAgICAgICAgPGkgY2xhc3M9XCJmYSBmYS1zb3J0LWFzY1wiIFtoaWRlXT1cInNvcnRBc2NcIj48L2k+XG4gICAgICAgICAgICAgIDxpIGNsYXNzPVwiZmEgZmEtc29ydC1kZXNjXCIgW2hpZGVdPVwiIXNvcnRBc2NcIj48L2k+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgIDxzcGFuICpuZ0lmPVwiY29sdW1uLnJlc2l6YWJsZVwiIGNsYXNzPVwiY29sdW1uLXJlc2l6ZS1oYW5kbGVcIlxuICAgICAgICAgICAgICAgIChtb3VzZWRvd24pPVwicmVzaXplQ29sdW1uU3RhcnQoJGV2ZW50LCBjb2x1bW4sIHRoKVwiPjwvc3Bhbj5cbiAgICAgICAgPC90aD5cbiAgICAgIDwvdHI+XG4gICAgICA8L3RoZWFkPlxuICAgICAgPHRib2R5ICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zOyBsZXQgaW5kZXg9aW5kZXhcIiBjbGFzcz1cImRhdGEtdGFibGUtcm93LXdyYXBwZXJcIlxuICAgICAgICAgICAgIGRhdGFUYWJsZVJvdyAjcm93IFtpdGVtXT1cIml0ZW1cIiBbaW5kZXhdPVwiaW5kZXhcIiAoc2VsZWN0ZWRDaGFuZ2UpPVwib25Sb3dTZWxlY3RDaGFuZ2VkKHJvdylcIj5cbiAgICAgIDwvdGJvZHk+XG4gICAgICA8dGJvZHkgY2xhc3M9XCJzdWJzdGl0dXRlLXJvd3NcIiAqbmdJZj1cInBhZ2luYXRpb24gJiYgc3Vic3RpdHV0ZVJvd3NcIj5cbiAgICAgIDx0ciAqbmdGb3I9XCJsZXQgaXRlbSBvZiBzdWJzdGl0dXRlSXRlbXMsIGxldCBpbmRleCA9IGluZGV4XCJcbiAgICAgICAgICBbY2xhc3Mucm93LW9kZF09XCIoaW5kZXggKyBpdGVtcy5sZW5ndGgpICUgMiA9PT0gMFwiXG4gICAgICAgICAgW2NsYXNzLnJvdy1ldmVuXT1cIihpbmRleCArIGl0ZW1zLmxlbmd0aCkgJSAyID09PSAxXCI+XG4gICAgICAgIDx0ZCBbaGlkZV09XCIhZXhwYW5kQ29sdW1uVmlzaWJsZVwiPjwvdGQ+XG4gICAgICAgIDx0ZCBbaGlkZV09XCIhaW5kZXhDb2x1bW5WaXNpYmxlXCI+Jm5ic3A7PC90ZD5cbiAgICAgICAgPHRkIFtoaWRlXT1cIiFzZWxlY3RDb2x1bW5WaXNpYmxlXCI+PC90ZD5cbiAgICAgICAgPHRkICpuZ0Zvcj1cImxldCBjb2x1bW4gb2YgY29sdW1uc1wiIFtoaWRlXT1cIiFjb2x1bW4udmlzaWJsZVwiPlxuICAgICAgPC90cj5cbiAgICAgIDwvdGJvZHk+XG4gICAgPC90YWJsZT5cbiAgICA8ZGl2IGNsYXNzPVwibG9hZGluZy1jb3ZlclwiICpuZ0lmPVwic2hvd1JlbG9hZGluZyAmJiByZWxvYWRpbmdcIj48L2Rpdj5cbiAgPC9kaXY+XG5cbiAgPGRhdGEtdGFibGUtcGFnaW5hdGlvbiAqbmdJZj1cInBhZ2luYXRpb25cIj48L2RhdGEtdGFibGUtcGFnaW5hdGlvbj5cbjwvZGl2PlxuYCxcbiAgc3R5bGVzOiBbYDpob3N0IC9kZWVwLyAuZGF0YS10YWJsZS50YWJsZT50Ym9keSt0Ym9keXtib3JkZXItdG9wOm5vbmV9Omhvc3QgL2RlZXAvIC5kYXRhLXRhYmxlLnRhYmxlIHRke3ZlcnRpY2FsLWFsaWduOm1pZGRsZX06aG9zdCAvZGVlcC8gLmRhdGEtdGFibGU+dGJvZHk+dHI+dGQsOmhvc3QgL2RlZXAvIC5kYXRhLXRhYmxlPnRoZWFkPnRyPnRoe292ZXJmbG93OmhpZGRlbn06aG9zdCAvZGVlcC8gLnJvdy1vZGR7YmFja2dyb3VuZC1jb2xvcjojZjZmNmY2fS5kYXRhLXRhYmxlIC5zdWJzdGl0dXRlLXJvd3M+dHI6aG92ZXIsOmhvc3QgL2RlZXAvIC5kYXRhLXRhYmxlIC5kYXRhLXRhYmxlLXJvdzpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNlY2VjZWN9LmRhdGEtdGFibGV7Ym94LXNoYWRvdzowIDAgMTVweCAjZWNlY2VjO3RhYmxlLWxheW91dDpmaXhlZH0uY29sdW1uLWhlYWRlcntwb3NpdGlvbjpyZWxhdGl2ZX0uZXhwYW5kLWNvbHVtbi1oZWFkZXJ7d2lkdGg6NTBweH0uc2VsZWN0LWNvbHVtbi1oZWFkZXJ7d2lkdGg6NTBweDt0ZXh0LWFsaWduOmNlbnRlcn0uaW5kZXgtY29sdW1uLWhlYWRlcnt3aWR0aDo0MHB4fS5jb2x1bW4taGVhZGVyLnNvcnRhYmxle2N1cnNvcjpwb2ludGVyfS5jb2x1bW4taGVhZGVyIC5jb2x1bW4tc29ydC1pY29ue2Zsb2F0OnJpZ2h0fS5jb2x1bW4taGVhZGVyLnJlc2l6YWJsZSAuY29sdW1uLXNvcnQtaWNvbnttYXJnaW4tcmlnaHQ6OHB4fS5jb2x1bW4taGVhZGVyIC5jb2x1bW4tc29ydC1pY29uIC5jb2x1bW4tc29ydGFibGUtaWNvbntjb2xvcjojZDNkM2QzfS5jb2x1bW4taGVhZGVyIC5jb2x1bW4tcmVzaXplLWhhbmRsZXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtyaWdodDowO21hcmdpbjowO3BhZGRpbmc6MDt3aWR0aDo4cHg7aGVpZ2h0OjEwMCU7Y3Vyc29yOmNvbC1yZXNpemV9LmRhdGEtdGFibGUtYm94e3Bvc2l0aW9uOnJlbGF0aXZlfS5sb2FkaW5nLWNvdmVye3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDI1NSwyNTUsMjU1LC4zKTt0b3A6MH1gXVxufSlcbmV4cG9ydCBjbGFzcyBEYXRhVGFibGU8VD4gaW1wbGVtZW50cyBEYXRhVGFibGVQYXJhbXMsIE9uSW5pdCB7XG5cbiAgLy8gVUkgc3RhdGUgd2l0aG91dCBpbnB1dDpcbiAgaW5kZXhDb2x1bW5WaXNpYmxlOiBib29sZWFuO1xuICBzZWxlY3RDb2x1bW5WaXNpYmxlOiBib29sZWFuO1xuICBleHBhbmRDb2x1bW5WaXNpYmxlOiBib29sZWFuO1xuXG4gIC8vIFVJIHN0YXRlOiB2aXNpYmxlIGdlL3NldCBmb3IgdGhlIG91dHNpZGUgd2l0aCBASW5wdXQgZm9yIG9uZS10aW1lIGluaXRpYWwgdmFsdWVzXG4gIHByaXZhdGUgX3NvcnRCeTogc3RyaW5nO1xuICBwcml2YXRlIF9zb3J0QXNjID0gdHJ1ZTtcbiAgcHJpdmF0ZSBfb2Zmc2V0ID0gMDtcbiAgcHJpdmF0ZSBfbGltaXQgPSAxMDtcbiAgcHJpdmF0ZSBfaXRlbXM6IFRbXSA9IFtdO1xuICBwcml2YXRlIF9zY2hlZHVsZWRSZWxvYWQ6IG51bWJlciA9IG51bGw7XG4gIHByaXZhdGUgX3NlbGVjdEFsbENoZWNrYm94ID0gZmFsc2U7XG4gIHByaXZhdGUgX2Rpc3BsYXlQYXJhbXMgPSA8RGF0YVRhYmxlUGFyYW1zPnt9O1xuICBwcml2YXRlIF9yZWxvYWRpbmcgPSBmYWxzZTtcbiAgcHJpdmF0ZSBfcmVzaXplSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gIHNlbGVjdGVkUm93OiBEYXRhVGFibGVSb3c8VD47XG4gIHNlbGVjdGVkUm93czogRGF0YVRhYmxlUm93PFQ+W10gPSBbXTtcbiAgcmVzaXplTGltaXQgPSAzMDtcblxuICBASW5wdXQoKVxuICBpdGVtQ291bnQ6IG51bWJlcjtcbiAgQElucHV0KClcbiAgcGFnaW5hdGlvbiA9IHRydWU7XG4gIEBJbnB1dCgpXG4gIGluZGV4Q29sdW1uID0gdHJ1ZTtcbiAgQElucHV0KClcbiAgaW5kZXhDb2x1bW5IZWFkZXIgPSAnJztcbiAgQElucHV0KClcbiAgcm93Q29sb3JzOiBSb3dDYWxsYmFjazxUPjtcbiAgQElucHV0KClcbiAgcm93VG9vbHRpcDogUm93Q2FsbGJhY2s8VD47XG4gIEBJbnB1dCgpXG4gIHNlbGVjdENvbHVtbiA9IGZhbHNlO1xuICBASW5wdXQoKVxuICBtdWx0aVNlbGVjdCA9IHRydWU7XG4gIEBJbnB1dCgpXG4gIHN1YnN0aXR1dGVSb3dzID0gdHJ1ZTtcbiAgQElucHV0KClcbiAgZXhwYW5kYWJsZVJvd3MgPSBmYWxzZTtcbiAgQElucHV0KClcbiAgdHJhbnNsYXRpb25zOiBEYXRhVGFibGVUcmFuc2xhdGlvbnMgPSBkZWZhdWx0VHJhbnNsYXRpb25zO1xuICBASW5wdXQoKVxuICBzZWxlY3RPblJvd0NsaWNrID0gZmFsc2U7XG4gIEBJbnB1dCgpXG4gIGF1dG9SZWxvYWQgPSB0cnVlO1xuICBASW5wdXQoKVxuICBzaG93UmVsb2FkaW5nID0gZmFsc2U7XG5cbiAgLy8gZXZlbnQgaGFuZGxlcnM6XG4gIEBPdXRwdXQoKVxuICByb3dDbGljazogRXZlbnRFbWl0dGVyPERhdGFUYWJsZVJvd0V2ZW50PFQ+PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgQE91dHB1dCgpXG4gIHJvd0V4cGFuZDogRXZlbnRFbWl0dGVyPERhdGFUYWJsZVJvd0V2ZW50PFQ+PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgQE91dHB1dCgpXG4gIHJvd0RvdWJsZUNsaWNrOiBFdmVudEVtaXR0ZXI8RGF0YVRhYmxlUm93RXZlbnQ8VD4+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICBAT3V0cHV0KClcbiAgaGVhZGVyQ2xpY2s6IEV2ZW50RW1pdHRlcjxEYXRhVGFibGVIZWFkZXJFdmVudDxUPj4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIEBPdXRwdXQoKVxuICBjZWxsQ2xpY2s6IEV2ZW50RW1pdHRlcjxEYXRhVGFibGVDZWxsRXZlbnQ8VD4+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICBAT3V0cHV0KClcbiAgcmVsb2FkOiBFdmVudEVtaXR0ZXI8RGF0YVRhYmxlUGFyYW1zPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAvLyBVSSBjb21wb25lbnRzOlxuICBAQ29udGVudENoaWxkKGZvcndhcmRSZWYoKCkgPT4gRGF0YVRhYmxlVGl0bGUpKVxuICB0aXRsZTogRGF0YVRhYmxlVGl0bGU7XG4gIEBDb250ZW50Q2hpbGRyZW4oRGF0YVRhYmxlQ29sdW1uKVxuICBjb2x1bW5zOiBRdWVyeUxpc3Q8RGF0YVRhYmxlQ29sdW1uPFQ+PjtcbiAgQFZpZXdDaGlsZHJlbihEYXRhVGFibGVSb3cpXG4gIHJvd3M6IFF1ZXJ5TGlzdDxEYXRhVGFibGVSb3c8VD4+O1xuICBAQ29udGVudENoaWxkKCdleHBhbmRUZW1wbGF0ZScpXG4gIGV4cGFuZFRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gIEBJbnB1dCgpXG4gIGdldCBpdGVtcygpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbXM7XG4gIH1cblxuICBzZXQgaXRlbXMoaXRlbXM6IGFueVtdKSB7XG4gICAgdGhpcy5faXRlbXMgPSBpdGVtcztcbiAgICB0aGlzLl9vblJlbG9hZEZpbmlzaGVkKCk7XG4gIH1cblxuICBASW5wdXQoKVxuICBnZXQgc29ydEJ5KCkge1xuICAgIHJldHVybiB0aGlzLl9zb3J0Qnk7XG4gIH1cblxuICBzZXQgc29ydEJ5KHZhbHVlKSB7XG4gICAgdGhpcy5fc29ydEJ5ID0gdmFsdWU7XG4gICAgdGhpcy5fdHJpZ2dlclJlbG9hZCgpO1xuICB9XG5cbiAgQElucHV0KClcbiAgZ2V0IHNvcnRBc2MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NvcnRBc2M7XG4gIH1cblxuICBzZXQgc29ydEFzYyh2YWx1ZSkge1xuICAgIHRoaXMuX3NvcnRBc2MgPSB2YWx1ZTtcbiAgICB0aGlzLl90cmlnZ2VyUmVsb2FkKCk7XG4gIH1cblxuICBASW5wdXQoKVxuICBnZXQgb2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9vZmZzZXQ7XG4gIH1cblxuICBzZXQgb2Zmc2V0KHZhbHVlKSB7XG4gICAgdGhpcy5fb2Zmc2V0ID0gdmFsdWU7XG4gICAgdGhpcy5fdHJpZ2dlclJlbG9hZCgpO1xuICB9XG5cbiAgQElucHV0KClcbiAgZ2V0IGxpbWl0KCkge1xuICAgIHJldHVybiB0aGlzLl9saW1pdDtcbiAgfVxuXG4gIHNldCBsaW1pdCh2YWx1ZSkge1xuICAgIHRoaXMuX2xpbWl0ID0gdmFsdWU7XG4gICAgdGhpcy5fdHJpZ2dlclJlbG9hZCgpO1xuICB9XG5cbiAgLy8gY2FsY3VsYXRlZCBwcm9wZXJ0eTpcbiAgQElucHV0KClcbiAgZ2V0IHBhZ2UoKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy5vZmZzZXQgLyB0aGlzLmxpbWl0KSArIDE7XG4gIH1cblxuICBzZXQgcGFnZSh2YWx1ZSkge1xuICAgIHRoaXMub2Zmc2V0ID0gKHZhbHVlIC0gMSkgKiB0aGlzLmxpbWl0O1xuICB9XG5cbiAgZ2V0IGxhc3RQYWdlKCkge1xuICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5pdGVtQ291bnQgLyB0aGlzLmxpbWl0KTtcbiAgfVxuXG4gIGdldCByZWxvYWRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlbG9hZGluZztcbiAgfVxuXG4gIGdldCBkaXNwbGF5UGFyYW1zKCkge1xuICAgIHJldHVybiB0aGlzLl9kaXNwbGF5UGFyYW1zO1xuICB9XG5cbiAgZ2V0IHNlbGVjdEFsbENoZWNrYm94KCkge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3RBbGxDaGVja2JveDtcbiAgfVxuXG4gIHNldCBzZWxlY3RBbGxDaGVja2JveCh2YWx1ZSkge1xuICAgIHRoaXMuX3NlbGVjdEFsbENoZWNrYm94ID0gdmFsdWU7XG4gICAgdGhpcy5fb25TZWxlY3RBbGxDaGFuZ2VkKHZhbHVlKTtcbiAgfVxuXG4gIGdldCBjb2x1bW5Db3VudCgpIHtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGNvdW50ICs9IHRoaXMuaW5kZXhDb2x1bW5WaXNpYmxlID8gMSA6IDA7XG4gICAgY291bnQgKz0gdGhpcy5zZWxlY3RDb2x1bW5WaXNpYmxlID8gMSA6IDA7XG4gICAgY291bnQgKz0gdGhpcy5leHBhbmRDb2x1bW5WaXNpYmxlID8gMSA6IDA7XG4gICAgdGhpcy5jb2x1bW5zLnRvQXJyYXkoKS5mb3JFYWNoKGNvbHVtbiA9PiB7XG4gICAgICBjb3VudCArPSBjb2x1bW4udmlzaWJsZSA/IDEgOiAwO1xuICAgIH0pO1xuICAgIHJldHVybiBjb3VudDtcbiAgfVxuXG4gIGdldCBzdWJzdGl0dXRlSXRlbXMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oe2xlbmd0aDogdGhpcy5kaXNwbGF5UGFyYW1zIS5saW1pdCAtIHRoaXMuaXRlbXMubGVuZ3RofSk7XG4gIH1cblxuICBnZXRSb3dDb2xvcihpdGVtOiBhbnksIGluZGV4OiBudW1iZXIsIHJvdzogRGF0YVRhYmxlUm93PFQ+KSB7XG4gICAgaWYgKHRoaXMucm93Q29sb3JzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAoPFJvd0NhbGxiYWNrPFQ+PnRoaXMucm93Q29sb3JzKShpdGVtLCByb3csIGluZGV4KTtcbiAgICB9XG4gIH1cblxuICAvLyBzZXR0aW5nIG11bHRpcGxlIG9ic2VydmFibGUgcHJvcGVydGllcyBzaW11bHRhbmVvdXNseVxuICBzb3J0KHNvcnRCeTogc3RyaW5nLCBhc2M6IGJvb2xlYW4pIHtcbiAgICB0aGlzLnNvcnRCeSA9IHNvcnRCeTtcbiAgICB0aGlzLnNvcnRBc2MgPSBhc2M7XG4gIH1cblxuICByZWxvYWRJdGVtcygpIHtcbiAgICB0aGlzLl9yZWxvYWRpbmcgPSB0cnVlO1xuICAgIHRoaXMucmVsb2FkLmVtaXQodGhpcy5fZ2V0UmVtb3RlUGFyYW1ldGVycygpKTtcbiAgfVxuXG4gIHJvd0NsaWNrZWQocm93OiBEYXRhVGFibGVSb3c8VD4sIGV2ZW50OiBNb3VzZUV2ZW50KSB7XG4gICAgdGhpcy5yb3dDbGljay5lbWl0KHtyb3csIGV2ZW50fSk7XG4gIH1cblxuICByb3dEb3VibGVDbGlja2VkKHJvdzogRGF0YVRhYmxlUm93PFQ+LCBldmVudDogTW91c2VFdmVudCkge1xuICAgIHRoaXMucm93RG91YmxlQ2xpY2suZW1pdCh7cm93LCBldmVudH0pO1xuICB9XG5cbiAgaGVhZGVyQ2xpY2tlZChjb2x1bW46IERhdGFUYWJsZUNvbHVtbjxUPiwgZXZlbnQ6IE1vdXNlRXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX3Jlc2l6ZUluUHJvZ3Jlc3MpIHtcbiAgICAgIHRoaXMuaGVhZGVyQ2xpY2suZW1pdCh7Y29sdW1uLCBldmVudH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0aGlzIGlzIGJlY2F1c2UgSSBjYW4ndCBwcmV2ZW50IGNsaWNrIGZyb20gbW91c3VwIG9mIHRoZSBkcmFnIGVuZFxuICAgICAgdGhpcy5fcmVzaXplSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGNlbGxDbGlja2VkKGNvbHVtbjogRGF0YVRhYmxlQ29sdW1uPFQ+LCByb3c6IERhdGFUYWJsZVJvdzxUPiwgZXZlbnQ6IE1vdXNlRXZlbnQpIHtcbiAgICB0aGlzLmNlbGxDbGljay5lbWl0KHtyb3csIGNvbHVtbiwgZXZlbnR9KTtcbiAgfVxuXG4gIHJvd0V4cGFuZGVkKHJvdzogRGF0YVRhYmxlUm93PFQ+LCBldmVudDogTW91c2VFdmVudCkge1xuICAgIHRoaXMucm93RXhwYW5kLmVtaXQoe3JvdywgZXZlbnR9KTtcbiAgfVxuXG4gIG9uUm93U2VsZWN0Q2hhbmdlZChyb3c6IERhdGFUYWJsZVJvdzxUPikge1xuICAgIC8vIG1haW50YWluIHRoZSBzZWxlY3RlZFJvdyhzKSB2aWV3XG4gICAgaWYgKHRoaXMubXVsdGlTZWxlY3QpIHtcbiAgICAgIGxldCBpbmRleCA9IHRoaXMuc2VsZWN0ZWRSb3dzLmluZGV4T2Yocm93KTtcbiAgICAgIGlmIChyb3cuc2VsZWN0ZWQgJiYgaW5kZXggPCAwKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRSb3dzLnB1c2gocm93KTtcbiAgICAgIH0gZWxzZSBpZiAoIXJvdy5zZWxlY3RlZCAmJiBpbmRleCA+PSAwKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRSb3dzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyb3cuc2VsZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZFJvdyA9IHJvdztcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5zZWxlY3RlZFJvdyA9PT0gcm93KSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRSb3cgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVuc2VsZWN0IGFsbCBvdGhlciByb3dzOlxuICAgIGlmIChyb3cuc2VsZWN0ZWQgJiYgIXRoaXMubXVsdGlTZWxlY3QpIHtcbiAgICAgIHRoaXMucm93cy50b0FycmF5KCkuZmlsdGVyKHJvd18gPT4gcm93Xy5zZWxlY3RlZCkuZm9yRWFjaChyb3dfID0+IHtcbiAgICAgICAgaWYgKHJvd18gIT09IHJvdykgeyAvLyBhdm9pZCBlbmRsZXNzIGxvb3BcbiAgICAgICAgICByb3dfLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJlc2l6ZUNvbHVtblN0YXJ0KGV2ZW50OiBNb3VzZUV2ZW50LCBjb2x1bW46IERhdGFUYWJsZUNvbHVtbjxUPiwgY29sdW1uRWxlbWVudDogSFRNTEVsZW1lbnQpIHtcbiAgICB0aGlzLl9yZXNpemVJblByb2dyZXNzID0gdHJ1ZTtcbiAgICBkcmFnKGV2ZW50LCB7XG4gICAgICBtb3ZlOiAobW92ZUV2ZW50OiBNb3VzZUV2ZW50LCBkeDogbnVtYmVyKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9pc1Jlc2l6ZUluTGltaXQoY29sdW1uRWxlbWVudCwgZHgpKSB7XG4gICAgICAgICAgY29sdW1uLndpZHRoID0gY29sdW1uRWxlbWVudC5vZmZzZXRXaWR0aCArIGR4O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgLy8gaW5pdFxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLl9pbml0RGVmYXVsdFZhbHVlcygpO1xuICAgIHRoaXMuX2luaXREZWZhdWx0Q2xpY2tFdmVudHMoKTtcbiAgICB0aGlzLl91cGRhdGVEaXNwbGF5UGFyYW1zKCk7XG4gICAgaWYgKHRoaXMuYXV0b1JlbG9hZCAmJiB0aGlzLl9zY2hlZHVsZWRSZWxvYWQgPT0gbnVsbCkge1xuICAgICAgdGhpcy5yZWxvYWRJdGVtcygpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2luaXREZWZhdWx0VmFsdWVzKCkge1xuICAgIHRoaXMuaW5kZXhDb2x1bW5WaXNpYmxlID0gdGhpcy5pbmRleENvbHVtbjtcbiAgICB0aGlzLnNlbGVjdENvbHVtblZpc2libGUgPSB0aGlzLnNlbGVjdENvbHVtbjtcbiAgICB0aGlzLmV4cGFuZENvbHVtblZpc2libGUgPSB0aGlzLmV4cGFuZGFibGVSb3dzO1xuICB9XG5cbiAgcHJpdmF0ZSBfaW5pdERlZmF1bHRDbGlja0V2ZW50cygpIHtcbiAgICB0aGlzLmhlYWRlckNsaWNrLnN1YnNjcmliZSh0YWJsZUV2ZW50ID0+IHRoaXMuX3NvcnRDb2x1bW4odGFibGVFdmVudC5jb2x1bW4pKTtcbiAgICBpZiAodGhpcy5zZWxlY3RPblJvd0NsaWNrKSB7XG4gICAgICB0aGlzLnJvd0NsaWNrLnN1YnNjcmliZSh0YWJsZUV2ZW50ID0+IHRhYmxlRXZlbnQucm93LnNlbGVjdGVkID0gIXRhYmxlRXZlbnQucm93LnNlbGVjdGVkKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9vblJlbG9hZEZpbmlzaGVkKCkge1xuICAgIHRoaXMuX3VwZGF0ZURpc3BsYXlQYXJhbXMoKTtcbiAgICB0aGlzLl9zZWxlY3RBbGxDaGVja2JveCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlbG9hZGluZyA9IGZhbHNlO1xuICB9XG5cbiAgcHJpdmF0ZSBfdXBkYXRlRGlzcGxheVBhcmFtcygpIHtcbiAgICB0aGlzLl9kaXNwbGF5UGFyYW1zID0ge1xuICAgICAgc29ydEJ5OiB0aGlzLnNvcnRCeSxcbiAgICAgIHNvcnRBc2M6IHRoaXMuc29ydEFzYyxcbiAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICBsaW1pdDogdGhpcy5saW1pdFxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIF90cmlnZ2VyUmVsb2FkKCkge1xuICAgIC8vIGZvciBhdm9pZGluZyBjYXNjYWRpbmcgcmVsb2FkcyBpZiBtdWx0aXBsZSBwYXJhbXMgYXJlIHNldCBhdCBvbmNlOlxuICAgIGlmICh0aGlzLl9zY2hlZHVsZWRSZWxvYWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9zY2hlZHVsZWRSZWxvYWQpO1xuICAgIH1cbiAgICB0aGlzLl9zY2hlZHVsZWRSZWxvYWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMucmVsb2FkSXRlbXMoKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgX2dldFJlbW90ZVBhcmFtZXRlcnMoKTogRGF0YVRhYmxlUGFyYW1zIHtcbiAgICBsZXQgcGFyYW1zID0gPERhdGFUYWJsZVBhcmFtcz57fTtcblxuICAgIGlmICh0aGlzLnNvcnRCeSkge1xuICAgICAgcGFyYW1zLnNvcnRCeSA9IHRoaXMuc29ydEJ5O1xuICAgICAgcGFyYW1zLnNvcnRBc2MgPSB0aGlzLnNvcnRBc2M7XG4gICAgfVxuICAgIGlmICh0aGlzLnBhZ2luYXRpb24pIHtcbiAgICAgIHBhcmFtcy5vZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgIHBhcmFtcy5saW1pdCA9IHRoaXMubGltaXQ7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICBwcml2YXRlIF9zb3J0Q29sdW1uKGNvbHVtbjogRGF0YVRhYmxlQ29sdW1uPFQ+KSB7XG4gICAgaWYgKGNvbHVtbi5zb3J0YWJsZSkge1xuICAgICAgbGV0IGFzY2VuZGluZyA9IHRoaXMuc29ydEJ5ID09PSBjb2x1bW4ucHJvcGVydHkgPyAhdGhpcy5zb3J0QXNjIDogdHJ1ZTtcbiAgICAgIHRoaXMuc29ydChjb2x1bW4ucHJvcGVydHksIGFzY2VuZGluZyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfb25TZWxlY3RBbGxDaGFuZ2VkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5yb3dzLnRvQXJyYXkoKS5mb3JFYWNoKHJvdyA9PiByb3cuc2VsZWN0ZWQgPSB2YWx1ZSk7XG4gIH1cblxuICBwcml2YXRlIF9pc1Jlc2l6ZUluTGltaXQoY29sdW1uRWxlbWVudDogSFRNTEVsZW1lbnQsIGR4OiBudW1iZXIpIHtcbiAgICAvKiBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIENTUyBtaW4td2lkdGggZGlkbid0IHdvcmsgb24gdGFibGUtbGF5b3V0OiBmaXhlZC5cbiAgICAgV2l0aG91dCB0aGUgbGltaXRzLCByZXNpemluZyBjYW4gbWFrZSB0aGUgbmV4dCBjb2x1bW4gZGlzYXBwZWFyIGNvbXBsZXRlbHksXG4gICAgIGFuZCBldmVuIGluY3JlYXNlIHRoZSB0YWJsZSB3aWR0aC4gVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gc3VmZmVycyBmcm9tIHRoZSBmYWN0LFxuICAgICB0aGF0IG9mZnNldFdpZHRoIHNvbWV0aW1lcyBjb250YWlucyBvdXQtb2YtZGF0ZSB2YWx1ZXMuICovXG4gICAgcmV0dXJuICEoKGR4IDwgMCAmJiAoY29sdW1uRWxlbWVudC5vZmZzZXRXaWR0aCArIGR4KSA8PSB0aGlzLnJlc2l6ZUxpbWl0KSB8fFxuICAgICAgIWNvbHVtbkVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nIHx8IC8vIHJlc2l6aW5nIGRvZXNuJ3QgbWFrZSBzZW5zZSBmb3IgdGhlIGxhc3QgdmlzaWJsZSBjb2x1bW5cbiAgICAgIChkeCA+PSAwICYmICgoPEhUTUxFbGVtZW50PiBjb2x1bW5FbGVtZW50Lm5leHRFbGVtZW50U2libGluZykub2Zmc2V0V2lkdGggKyBkeCkgPD0gdGhpcy5yZXNpemVMaW1pdCkpO1xuICB9XG59XG4iLCJpbXBvcnQge0NvbXBvbmVudCwgZm9yd2FyZFJlZiwgSG9zdExpc3RlbmVyLCBJbmplY3R9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtEYXRhVGFibGV9IGZyb20gJy4uLy4uLyc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2RhdGEtdGFibGUtdGl0bGUnLFxuICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJuYXZiYXJcIj5cbiAgPGg0IGNsYXNzPVwidGl0bGVcIiBbdGV4dENvbnRlbnRdPVwiZGF0YVRhYmxlLnRpdGxlLnRpdGxlXCI+PC9oND5cbiAgPG5nLWNvbnRhaW5lciAqbmdJZj1cImRhdGFUYWJsZS50aXRsZS50aXRsZVRlbXBsYXRlXCIgW25nVGVtcGxhdGVPdXRsZXRdPVwiZGF0YVRhYmxlLnRpdGxlLnRpdGxlVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7aXRlbXM6IGRhdGFUYWJsZS5pdGVtc31cIj5cbiAgPC9uZy1jb250YWluZXI+XG4gIDxkaXYgKm5nSWY9XCJkYXRhVGFibGUudGl0bGUuY29udHJvbHNcIj5cbiAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tZGVmYXVsdCBidG4tc20gcmVmcmVzaC1idXR0b25cIiAoY2xpY2spPVwiZGF0YVRhYmxlLnJlbG9hZEl0ZW1zKClcIj5cbiAgICAgIDxpIGNsYXNzPVwiZmEgZmEtcmVmcmVzaFwiPjwvaT5cbiAgICA8L2J1dHRvbj5cbiAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tZGVmYXVsdCBidG4tc20gY29sdW1uLXNlbGVjdG9yLWJ1dHRvblwiIFtjbGFzcy5hY3RpdmVdPVwiY29sdW1uU2VsZWN0b3JPcGVuXCJcbiAgICAgICAgICAgIChjbGljayk9XCJjb2x1bW5TZWxlY3Rvck9wZW4gPSAhY29sdW1uU2VsZWN0b3JPcGVuOyAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcIj5cbiAgICAgIDxpIGNsYXNzPVwiZmEgZmEtbGlzdFwiPjwvaT5cbiAgICA8L2J1dHRvbj5cbiAgICA8ZGl2IGNsYXNzPVwiY29sdW1uLXNlbGVjdG9yLXdyYXBwZXJcIiAoY2xpY2spPVwiJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXCI+XG4gICAgICA8ZGl2ICpuZ0lmPVwiY29sdW1uU2VsZWN0b3JPcGVuXCIgY2xhc3M9XCJjb2x1bW4tc2VsZWN0b3ItYm94IGNhcmRcIj5cbiAgICAgICAgPGRpdiAqbmdJZj1cImRhdGFUYWJsZS5leHBhbmRhYmxlUm93c1wiIGNsYXNzPVwiY29sdW1uLXNlbGVjdG9yLWZpeGVkLWNvbHVtbiBjaGVja2JveFwiPlxuICAgICAgICAgIDxsYWJlbD5cbiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBbKG5nTW9kZWwpXT1cImRhdGFUYWJsZS5leHBhbmRDb2x1bW5WaXNpYmxlXCIvPlxuICAgICAgICAgICAgPHNwYW4+e3tkYXRhVGFibGUudHJhbnNsYXRpb25zLmV4cGFuZENvbHVtbn19PC9zcGFuPlxuICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2ICpuZ0lmPVwiZGF0YVRhYmxlLmluZGV4Q29sdW1uXCIgY2xhc3M9XCJjb2x1bW4tc2VsZWN0b3ItZml4ZWQtY29sdW1uIGNoZWNrYm94XCI+XG4gICAgICAgICAgPGxhYmVsPlxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIFsobmdNb2RlbCldPVwiZGF0YVRhYmxlLmluZGV4Q29sdW1uVmlzaWJsZVwiLz5cbiAgICAgICAgICAgIDxzcGFuPnt7ZGF0YVRhYmxlLnRyYW5zbGF0aW9ucy5pbmRleENvbHVtbn19PC9zcGFuPlxuICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2ICpuZ0lmPVwiZGF0YVRhYmxlLnNlbGVjdENvbHVtblwiIGNsYXNzPVwiY29sdW1uLXNlbGVjdG9yLWZpeGVkLWNvbHVtbiBjaGVja2JveFwiPlxuICAgICAgICAgIDxsYWJlbD5cbiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBbKG5nTW9kZWwpXT1cImRhdGFUYWJsZS5zZWxlY3RDb2x1bW5WaXNpYmxlXCIvPlxuICAgICAgICAgICAgPHNwYW4+e3tkYXRhVGFibGUudHJhbnNsYXRpb25zLnNlbGVjdENvbHVtbn19PC9zcGFuPlxuICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2ICpuZ0Zvcj1cImxldCBjb2x1bW4gb2YgZGF0YVRhYmxlLmNvbHVtbnNcIiBjbGFzcz1cImNvbHVtbi1zZWxlY3Rvci1jb2x1bW4gY2hlY2tib3hcIj5cbiAgICAgICAgICA8bGFiZWw+XG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgWyhuZ01vZGVsKV09XCJjb2x1bW4udmlzaWJsZVwiLz5cbiAgICAgICAgICAgIDxzcGFuIFt0ZXh0Q29udGVudF09XCJjb2x1bW4uaGVhZGVyXCI+PC9zcGFuPlxuICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC9kaXY+XG5gLFxuICBzdHlsZXM6IFtgLm5hdmJhcntwYWRkaW5nOjEwcHggMH0ubmF2YmFyIC50aXRsZXttYXJnaW46NXB4IDAgMCA1cHh9LmNvbHVtbi1zZWxlY3Rvci13cmFwcGVye3Bvc2l0aW9uOnJlbGF0aXZlfS5jb2x1bW4tc2VsZWN0b3Itd3JhcHBlciAuY29sdW1uLXNlbGVjdG9yLWJveHtib3gtc2hhZG93OjAgMCAxMHB4ICNkM2QzZDM7d2lkdGg6MTUwcHg7cGFkZGluZzoxMHB4O3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjFweDt6LWluZGV4OjEwNjB9LmNvbHVtbi1zZWxlY3Rvci13cmFwcGVyIC5jb2x1bW4tc2VsZWN0b3ItYm94IC5jaGVja2JveHttYXJnaW4tYm90dG9tOjRweH0uY29sdW1uLXNlbGVjdG9yLXdyYXBwZXIgLmNvbHVtbi1zZWxlY3Rvci1ib3ggLmNvbHVtbi1zZWxlY3Rvci1maXhlZC1jb2x1bW57Zm9udC1zdHlsZTppdGFsaWN9YF1cbn0pXG5leHBvcnQgY2xhc3MgRGF0YVRhYmxlVGl0bGVDb21wb25lbnQ8VD4ge1xuXG4gIGNvbHVtblNlbGVjdG9yT3BlbiA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBEYXRhVGFibGUpKSBwdWJsaWMgZGF0YVRhYmxlOiBEYXRhVGFibGU8VD4pIHtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2RvY3VtZW50OmNsaWNrJywgWyckZXZlbnQnXSlcbiAgX2Nsb3NlU2VsZWN0b3IoJGV2ZW50KSB7XG4gICAgdGhpcy5jb2x1bW5TZWxlY3Rvck9wZW4gPSBmYWxzZTtcbiAgfVxufVxuXG4iLCJpbXBvcnQge0NvbnRlbnRDaGlsZCwgRGlyZWN0aXZlLCBJbnB1dCwgVGVtcGxhdGVSZWZ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdkYXRhLXRhYmxlLXRpdGxlJ1xufSlcbmV4cG9ydCBjbGFzcyBEYXRhVGFibGVUaXRsZSB7XG5cbiAgQElucHV0KClcbiAgdGl0bGUgPSAnJztcbiAgQENvbnRlbnRDaGlsZCgndGl0bGVUZW1wbGF0ZScpXG4gIHRpdGxlVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG4gIEBJbnB1dCgpXG4gIGNvbnRyb2xzID0gdHJ1ZTtcbn1cbiIsImltcG9ydCB7RGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbnB1dCwgUmVuZGVyZXJ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5cbmZ1bmN0aW9uIGlzQmxhbmsob2JqOiBhbnkpOiBib29sZWFuIHtcbiAgcmV0dXJuIG9iaiA9PT0gdW5kZWZpbmVkIHx8IG9iaiA9PT0gbnVsbDtcbn1cblxuQERpcmVjdGl2ZSh7c2VsZWN0b3I6ICdbaGlkZV0nfSlcbmV4cG9ydCBjbGFzcyBIaWRlRGlyZWN0aXZlIHtcblxuICBwcml2YXRlIF9wcmV2Q29uZGl0aW9uOiBib29sZWFuID0gbnVsbDtcbiAgcHJpdmF0ZSBfZGlzcGxheVN0eWxlOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcHJpdmF0ZSBfcmVuZGVyZXI6IFJlbmRlcmVyKSB7XG4gIH1cblxuICBASW5wdXQoKVxuICBzZXQgaGlkZShuZXdDb25kaXRpb246IGJvb2xlYW4pIHtcbiAgICB0aGlzLmluaXREaXNwbGF5U3R5bGUoKTtcblxuICAgIGlmIChuZXdDb25kaXRpb24gJiYgKGlzQmxhbmsodGhpcy5fcHJldkNvbmRpdGlvbikgfHwgIXRoaXMuX3ByZXZDb25kaXRpb24pKSB7XG4gICAgICB0aGlzLl9wcmV2Q29uZGl0aW9uID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRTdHlsZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICB9IGVsc2UgaWYgKCFuZXdDb25kaXRpb24gJiYgKGlzQmxhbmsodGhpcy5fcHJldkNvbmRpdGlvbikgfHwgdGhpcy5fcHJldkNvbmRpdGlvbikpIHtcbiAgICAgIHRoaXMuX3ByZXZDb25kaXRpb24gPSBmYWxzZTtcbiAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRTdHlsZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdkaXNwbGF5JywgdGhpcy5fZGlzcGxheVN0eWxlKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGluaXREaXNwbGF5U3R5bGUoKSB7XG4gICAgaWYgKHRoaXMuX2Rpc3BsYXlTdHlsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXQgZGlzcGxheVN0eWxlID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnN0eWxlLmRpc3BsYXk7XG4gICAgICBpZiAoZGlzcGxheVN0eWxlICYmIGRpc3BsYXlTdHlsZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgIHRoaXMuX2Rpc3BsYXlTdHlsZSA9IGRpc3BsYXlTdHlsZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7UGlwZSwgUGlwZVRyYW5zZm9ybX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBQaXBlKHtcbiAgbmFtZTogJ21pbidcbn0pXG5leHBvcnQgY2xhc3MgTWluUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuXG4gIHRyYW5zZm9ybSh2YWx1ZTogbnVtYmVyW10sIC4uLmFyZ3M6IGFueVtdKTogYW55IHtcbiAgICByZXR1cm4gTWF0aC5taW4uYXBwbHkobnVsbCwgdmFsdWUpO1xuICB9XG59XG4iLCJpbXBvcnQge1BpcGUsIFBpcGVUcmFuc2Zvcm19IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AUGlwZSh7XG4gIG5hbWU6ICdweCdcbn0pXG5leHBvcnQgY2xhc3MgUHhQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG5cbiAgdHJhbnNmb3JtKHZhbHVlOiBzdHJpbmcgfCBudW1iZXIsIC4uLmFyZ3M6IGFueVtdKTogYW55IHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpID49IDAgPyBgJHt2YWx1ZX1weGAgOiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7RGF0YVRhYmxlUGFyYW1zfSBmcm9tICcuLic7XG5cblxuZXhwb3J0IGNsYXNzIERhdGFUYWJsZVJlc291cmNlPFQ+IHtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGl0ZW1zOiBUW10pIHtcbiAgfVxuXG4gIHF1ZXJ5KHBhcmFtczogRGF0YVRhYmxlUGFyYW1zLCBmaWx0ZXI/OiAoaXRlbTogVCwgaW5kZXg6IG51bWJlciwgaXRlbXM6IFRbXSkgPT4gYm9vbGVhbik6IFByb21pc2U8VFtdPiB7XG5cbiAgICBsZXQgcmVzdWx0OiBUW10gPSBbXTtcbiAgICBpZiAoZmlsdGVyKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLml0ZW1zLmZpbHRlcihmaWx0ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSB0aGlzLml0ZW1zLnNsaWNlKCk7IC8vIHNoYWxsb3cgY29weSB0byB1c2UgZm9yIHNvcnRpbmcgaW5zdGVhZCBvZiBjaGFuZ2luZyB0aGUgb3JpZ2luYWxcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLnNvcnRCeSkge1xuICAgICAgcmVzdWx0LnNvcnQoKGE6IGFueSwgYjogYW55KSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgYVtwYXJhbXMuc29ydEJ5XSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gYVtwYXJhbXMuc29ydEJ5XS5sb2NhbGVDb21wYXJlKGJbcGFyYW1zLnNvcnRCeV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBhW3BhcmFtcy5zb3J0QnldIC0gYltwYXJhbXMuc29ydEJ5XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAocGFyYW1zLnNvcnRBc2MgPT09IGZhbHNlKSB7XG4gICAgICAgIHJlc3VsdC5yZXZlcnNlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJhbXMub2Zmc2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChwYXJhbXMubGltaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UocGFyYW1zLm9mZnNldCwgcmVzdWx0Lmxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UocGFyYW1zLm9mZnNldCwgcGFyYW1zLm9mZnNldCArIHBhcmFtcy5saW1pdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gcmVzb2x2ZShyZXN1bHQpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNvdW50KCk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gcmVzb2x2ZSh0aGlzLml0ZW1zLmxlbmd0aCkpO1xuICAgIH0pO1xuICB9XG59XG4iLCJpbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtEYXRhVGFibGVDb2x1bW59IGZyb20gJy4vY29tcG9uZW50cy9jb2x1bW4vY29sdW1uLmRpcmVjdGl2ZSc7XG5pbXBvcnQge0RhdGFUYWJsZVBhZ2luYXRpb259IGZyb20gJy4vY29tcG9uZW50cy9wYWdpbmF0aW9uL3BhZ2luYXRpb24uY29tcG9uZW50JztcbmltcG9ydCB7RGF0YVRhYmxlUm93fSBmcm9tICcuL2NvbXBvbmVudHMvcm93L3Jvdy5jb21wb25lbnQnO1xuaW1wb3J0IHtEYXRhVGFibGV9IGZyb20gJy4vY29tcG9uZW50cy90YWJsZS90YWJsZS5jb21wb25lbnQnO1xuaW1wb3J0IHtEYXRhVGFibGVUaXRsZUNvbXBvbmVudH0gZnJvbSAnLi9jb21wb25lbnRzL3RpdGxlL3RpdGxlLmNvbXBvbmVudCc7XG5pbXBvcnQge0RhdGFUYWJsZVRpdGxlfSBmcm9tICcuL2NvbXBvbmVudHMvdGl0bGUvdGl0bGUuZGlyZWN0aXZlJztcbmltcG9ydCB7SGlkZURpcmVjdGl2ZX0gZnJvbSAnLi91dGlscy9oaWRlLmRpcmVjdGl2ZSc7XG5pbXBvcnQge01pblBpcGV9IGZyb20gJy4vdXRpbHMvbWluLnBpcGUnO1xuaW1wb3J0IHtQeFBpcGV9IGZyb20gJy4vdXRpbHMvcHgucGlwZSc7XG5cbmV4cG9ydCAqIGZyb20gJy4vY29tcG9uZW50cy90eXBlcyc7XG5leHBvcnQgKiBmcm9tICcuL3Rvb2xzL2RhdGEtdGFibGUtcmVzb3VyY2UnO1xuXG5leHBvcnQge0RhdGFUYWJsZSwgRGF0YVRhYmxlQ29sdW1uLCBEYXRhVGFibGVSb3csIERhdGFUYWJsZVRpdGxlLCBEYXRhVGFibGVQYWdpbmF0aW9ufTtcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW1xuICAgIENvbW1vbk1vZHVsZSxcbiAgICBGb3Jtc01vZHVsZVxuICBdLFxuICBkZWNsYXJhdGlvbnM6IFtcbiAgICBEYXRhVGFibGUsXG4gICAgRGF0YVRhYmxlQ29sdW1uLFxuICAgIERhdGFUYWJsZVRpdGxlLFxuICAgIERhdGFUYWJsZVJvdyxcbiAgICBEYXRhVGFibGVQYWdpbmF0aW9uLFxuICAgIERhdGFUYWJsZVRpdGxlQ29tcG9uZW50LFxuICAgIFB4UGlwZSxcbiAgICBIaWRlRGlyZWN0aXZlLFxuICAgIE1pblBpcGVcbiAgXSxcbiAgZXhwb3J0czogW0RhdGFUYWJsZSwgRGF0YVRhYmxlQ29sdW1uLCBEYXRhVGFibGVUaXRsZSwgRGF0YVRhYmxlUGFnaW5hdGlvbl1cbn0pXG5leHBvcnQgY2xhc3MgRGF0YVRhYmxlTW9kdWxlIHtcbn1cbiJdLCJuYW1lcyI6WyJEYXRhVGFibGUiLCJEYXRhVGFibGVSb3ciLCJEYXRhVGFibGVQYWdpbmF0aW9uIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztB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