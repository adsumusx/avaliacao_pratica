/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Component, forwardRef, Inject } from '@angular/core';
import { DataTable } from '../../';
/**
 * @template T
 */
export class DataTablePagination {
    /**
     * @param {?} dataTable
     */
    constructor(dataTable) {
        this.dataTable = dataTable;
    }
    /**
     * @return {?}
     */
    get maxPage() {
        return Math.ceil(this.dataTable.itemCount / this.dataTable.limit);
    }
    /**
     * @return {?}
     */
    get limit() {
        return this.dataTable.limit;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set limit(value) {
        if (Number(value) > 0) {
            this.dataTable.limit = Math.floor(+value);
        }
    }
    /**
     * @return {?}
     */
    get page() {
        return this.dataTable.page;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set page(value) {
        if (Number(value) > 0) {
            this.dataTable.page = Math.floor(+value);
        }
    }
    /**
     * @return {?}
     */
    pageBack() {
        this.dataTable.offset -= Math.min(this.dataTable.limit, this.dataTable.offset);
    }
    /**
     * @return {?}
     */
    pageForward() {
        this.dataTable.offset += this.dataTable.limit;
    }
    /**
     * @return {?}
     */
    pageFirst() {
        this.dataTable.offset = 0;
    }
    /**
     * @return {?}
     */
    pageLast() {
        this.dataTable.offset = (this.maxPage - 1) * this.dataTable.limit;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    keyPress(event) {
        let /** @type {?} */ inputChar = String.fromCharCode(event.charCode);
        if (!(Number(inputChar) >= 0)) {
            event.preventDefault();
        }
    }
}
DataTablePagination.decorators = [
    { type: Component, args: [{
                selector: 'data-table-pagination',
                template: `<div class="navbar p-0 pagination-component">
  <div>
    {{dataTable.translations.paginationRange}}:&nbsp;{{dataTable.offset < 0 ? 0 : dataTable.offset + 1}}&nbsp;-
    {{[dataTable.offset + dataTable.limit , dataTable.itemCount] | min}}&nbsp;/&nbsp;{{dataTable.itemCount}}
  </div>
  <ul class="nav justify-content-end">
    <li class="nav-item pagination-limit">
      <div class="input-group">
        <div class="input-group-prepend">
          <span class="input-group-text">{{dataTable.translations.paginationLimit}}:</span>
        </div>
        <input #limitInput type="number" class="form-control" min="1" step="1"
               [ngModel]="limit" (blur)="limit = limitInput.value"
               (keyup.enter)="limit = limitInput.value"
               (keyup.esc)="limitInput.value = limit"
               (keypress)="keyPress($event)"/>
      </div>
    </li>
    <li class="nav-item">
      <button [disabled]="dataTable.offset <= 0" (click)="pageFirst()" class="btn btn-default">&laquo;</button>
      <button [disabled]="dataTable.offset <= 0" (click)="pageBack()" class="btn btn-default">&lsaquo;</button>
      <div class="d-inline-block">
        <div class="input-group">
          <input #pageInput type="number" class="form-control" min="1" step="1" max="{{maxPage}}"
                 [ngModel]="page" (blur)="page = pageInput.value"
                 (keyup.enter)="page = pageInput.value" (keyup.esc)="pageInput.value = page"
                 (keypress)="keyPress($event)"/>
          <div class="input-group-append">
            <span class="input-group-text">/&nbsp;{{dataTable.lastPage}}</span>
          </div>
        </div>
      </div>
      <button [disabled]="(dataTable.offset + dataTable.limit) >= dataTable.itemCount" (click)="pageForward()"
              class="btn btn-default">&rsaquo;
      </button>
      <button [disabled]="(dataTable.offset + dataTable.limit) >= dataTable.itemCount" (click)="pageLast()"
              class="btn btn-default">&raquo;
      </button>
    </li>
  </ul>
</div>
`,
                styles: [`.pagination-component .pagination-limit{margin-right:1rem}.pagination-component .pagination-limit input{width:75px}.pagination-component .btn{margin-top:-3px}`]
            },] },
];
/** @nocollapse */
DataTablePagination.ctorParameters = () => [
    { type: DataTable, decorators: [{ type: Inject, args: [forwardRef(() => DataTable),] }] }
];
function DataTablePagination_tsickle_Closure_declarations() {
    /** @type {?} */
    DataTablePagination.prototype.dataTable;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFnaW5hdGlvbi5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtZGF0YXRhYmxlLWJvb3RzdHJhcDQvIiwic291cmNlcyI6WyJjb21wb25lbnRzL3BhZ2luYXRpb24vcGFnaW5hdGlvbi5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBQyxTQUFTLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUM1RCxPQUFPLEVBQUMsU0FBUyxFQUFDLE1BQU0sUUFBUSxDQUFDOzs7O0FBaURqQyxNQUFNOzs7O0lBRUosWUFBd0QsU0FBdUI7UUFBdkIsY0FBUyxHQUFULFNBQVMsQ0FBYztLQUM5RTs7OztJQUVELElBQUksT0FBTztRQUNULE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDbkU7Ozs7SUFFRCxJQUFJLEtBQUs7UUFDUCxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUM7S0FDN0I7Ozs7O0lBRUQsSUFBSSxLQUFLLENBQUMsS0FBSztRQUNiLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3RCLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUMzQztLQUNGOzs7O0lBRUQsSUFBSSxJQUFJO1FBQ04sTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDO0tBQzVCOzs7OztJQUVELElBQUksSUFBSSxDQUFDLEtBQUs7UUFDWixFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN0QixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDMUM7S0FDRjs7OztJQUVELFFBQVE7UUFDTixJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7S0FDaEY7Ozs7SUFFRCxXQUFXO1FBQ1QsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUM7S0FDL0M7Ozs7SUFFRCxTQUFTO1FBQ1AsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0tBQzNCOzs7O0lBRUQsUUFBUTtRQUNOLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQztLQUNuRTs7Ozs7SUFFRCxRQUFRLENBQUMsS0FBVTtRQUNqQixxQkFBSSxTQUFTLEdBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDcEQsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDOUIsS0FBSyxDQUFDLGNBQWMsRUFBRSxDQUFDO1NBQ3hCO0tBQ0Y7OztZQWhHRixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLHVCQUF1QjtnQkFDakMsUUFBUSxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXlDWDtnQkFDQyxNQUFNLEVBQUUsQ0FBQyxnS0FBZ0ssQ0FBQzthQUMzSzs7OztZQWhETyxTQUFTLHVCQW1ERixNQUFNLFNBQUMsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLFNBQVMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Q29tcG9uZW50LCBmb3J3YXJkUmVmLCBJbmplY3R9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtEYXRhVGFibGV9IGZyb20gJy4uLy4uLyc7XG5cblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnZGF0YS10YWJsZS1wYWdpbmF0aW9uJyxcbiAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwibmF2YmFyIHAtMCBwYWdpbmF0aW9uLWNvbXBvbmVudFwiPlxuICA8ZGl2PlxuICAgIHt7ZGF0YVRhYmxlLnRyYW5zbGF0aW9ucy5wYWdpbmF0aW9uUmFuZ2V9fTombmJzcDt7e2RhdGFUYWJsZS5vZmZzZXQgPCAwID8gMCA6IGRhdGFUYWJsZS5vZmZzZXQgKyAxfX0mbmJzcDstXG4gICAge3tbZGF0YVRhYmxlLm9mZnNldCArIGRhdGFUYWJsZS5saW1pdCAsIGRhdGFUYWJsZS5pdGVtQ291bnRdIHwgbWlufX0mbmJzcDsvJm5ic3A7e3tkYXRhVGFibGUuaXRlbUNvdW50fX1cbiAgPC9kaXY+XG4gIDx1bCBjbGFzcz1cIm5hdiBqdXN0aWZ5LWNvbnRlbnQtZW5kXCI+XG4gICAgPGxpIGNsYXNzPVwibmF2LWl0ZW0gcGFnaW5hdGlvbi1saW1pdFwiPlxuICAgICAgPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cC1wcmVwZW5kXCI+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC10ZXh0XCI+e3tkYXRhVGFibGUudHJhbnNsYXRpb25zLnBhZ2luYXRpb25MaW1pdH19Ojwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxpbnB1dCAjbGltaXRJbnB1dCB0eXBlPVwibnVtYmVyXCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBtaW49XCIxXCIgc3RlcD1cIjFcIlxuICAgICAgICAgICAgICAgW25nTW9kZWxdPVwibGltaXRcIiAoYmx1cik9XCJsaW1pdCA9IGxpbWl0SW5wdXQudmFsdWVcIlxuICAgICAgICAgICAgICAgKGtleXVwLmVudGVyKT1cImxpbWl0ID0gbGltaXRJbnB1dC52YWx1ZVwiXG4gICAgICAgICAgICAgICAoa2V5dXAuZXNjKT1cImxpbWl0SW5wdXQudmFsdWUgPSBsaW1pdFwiXG4gICAgICAgICAgICAgICAoa2V5cHJlc3MpPVwia2V5UHJlc3MoJGV2ZW50KVwiLz5cbiAgICAgIDwvZGl2PlxuICAgIDwvbGk+XG4gICAgPGxpIGNsYXNzPVwibmF2LWl0ZW1cIj5cbiAgICAgIDxidXR0b24gW2Rpc2FibGVkXT1cImRhdGFUYWJsZS5vZmZzZXQgPD0gMFwiIChjbGljayk9XCJwYWdlRmlyc3QoKVwiIGNsYXNzPVwiYnRuIGJ0bi1kZWZhdWx0XCI+JmxhcXVvOzwvYnV0dG9uPlxuICAgICAgPGJ1dHRvbiBbZGlzYWJsZWRdPVwiZGF0YVRhYmxlLm9mZnNldCA8PSAwXCIgKGNsaWNrKT1cInBhZ2VCYWNrKClcIiBjbGFzcz1cImJ0biBidG4tZGVmYXVsdFwiPiZsc2FxdW87PC9idXR0b24+XG4gICAgICA8ZGl2IGNsYXNzPVwiZC1pbmxpbmUtYmxvY2tcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwXCI+XG4gICAgICAgICAgPGlucHV0ICNwYWdlSW5wdXQgdHlwZT1cIm51bWJlclwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgbWluPVwiMVwiIHN0ZXA9XCIxXCIgbWF4PVwie3ttYXhQYWdlfX1cIlxuICAgICAgICAgICAgICAgICBbbmdNb2RlbF09XCJwYWdlXCIgKGJsdXIpPVwicGFnZSA9IHBhZ2VJbnB1dC52YWx1ZVwiXG4gICAgICAgICAgICAgICAgIChrZXl1cC5lbnRlcik9XCJwYWdlID0gcGFnZUlucHV0LnZhbHVlXCIgKGtleXVwLmVzYyk9XCJwYWdlSW5wdXQudmFsdWUgPSBwYWdlXCJcbiAgICAgICAgICAgICAgICAgKGtleXByZXNzKT1cImtleVByZXNzKCRldmVudClcIi8+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwLWFwcGVuZFwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC10ZXh0XCI+LyZuYnNwO3t7ZGF0YVRhYmxlLmxhc3RQYWdlfX08L3NwYW4+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgICA8YnV0dG9uIFtkaXNhYmxlZF09XCIoZGF0YVRhYmxlLm9mZnNldCArIGRhdGFUYWJsZS5saW1pdCkgPj0gZGF0YVRhYmxlLml0ZW1Db3VudFwiIChjbGljayk9XCJwYWdlRm9yd2FyZCgpXCJcbiAgICAgICAgICAgICAgY2xhc3M9XCJidG4gYnRuLWRlZmF1bHRcIj4mcnNhcXVvO1xuICAgICAgPC9idXR0b24+XG4gICAgICA8YnV0dG9uIFtkaXNhYmxlZF09XCIoZGF0YVRhYmxlLm9mZnNldCArIGRhdGFUYWJsZS5saW1pdCkgPj0gZGF0YVRhYmxlLml0ZW1Db3VudFwiIChjbGljayk9XCJwYWdlTGFzdCgpXCJcbiAgICAgICAgICAgICAgY2xhc3M9XCJidG4gYnRuLWRlZmF1bHRcIj4mcmFxdW87XG4gICAgICA8L2J1dHRvbj5cbiAgICA8L2xpPlxuICA8L3VsPlxuPC9kaXY+XG5gLFxuICBzdHlsZXM6IFtgLnBhZ2luYXRpb24tY29tcG9uZW50IC5wYWdpbmF0aW9uLWxpbWl0e21hcmdpbi1yaWdodDoxcmVtfS5wYWdpbmF0aW9uLWNvbXBvbmVudCAucGFnaW5hdGlvbi1saW1pdCBpbnB1dHt3aWR0aDo3NXB4fS5wYWdpbmF0aW9uLWNvbXBvbmVudCAuYnRue21hcmdpbi10b3A6LTNweH1gXVxufSlcbmV4cG9ydCBjbGFzcyBEYXRhVGFibGVQYWdpbmF0aW9uPFQ+IHtcblxuICBjb25zdHJ1Y3RvcihASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gRGF0YVRhYmxlKSkgcHVibGljIGRhdGFUYWJsZTogRGF0YVRhYmxlPFQ+KSB7XG4gIH1cblxuICBnZXQgbWF4UGFnZSgpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuZGF0YVRhYmxlLml0ZW1Db3VudCAvIHRoaXMuZGF0YVRhYmxlLmxpbWl0KTtcbiAgfVxuXG4gIGdldCBsaW1pdCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhVGFibGUubGltaXQ7XG4gIH1cblxuICBzZXQgbGltaXQodmFsdWUpIHtcbiAgICBpZiAoTnVtYmVyKHZhbHVlKSA+IDApIHtcbiAgICAgIHRoaXMuZGF0YVRhYmxlLmxpbWl0ID0gTWF0aC5mbG9vcigrdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBwYWdlKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGFUYWJsZS5wYWdlO1xuICB9XG5cbiAgc2V0IHBhZ2UodmFsdWUpIHtcbiAgICBpZiAoTnVtYmVyKHZhbHVlKSA+IDApIHtcbiAgICAgIHRoaXMuZGF0YVRhYmxlLnBhZ2UgPSBNYXRoLmZsb29yKCt2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcGFnZUJhY2soKSB7XG4gICAgdGhpcy5kYXRhVGFibGUub2Zmc2V0IC09IE1hdGgubWluKHRoaXMuZGF0YVRhYmxlLmxpbWl0LCB0aGlzLmRhdGFUYWJsZS5vZmZzZXQpO1xuICB9XG5cbiAgcGFnZUZvcndhcmQoKSB7XG4gICAgdGhpcy5kYXRhVGFibGUub2Zmc2V0ICs9IHRoaXMuZGF0YVRhYmxlLmxpbWl0O1xuICB9XG5cbiAgcGFnZUZpcnN0KCkge1xuICAgIHRoaXMuZGF0YVRhYmxlLm9mZnNldCA9IDA7XG4gIH1cblxuICBwYWdlTGFzdCgpIHtcbiAgICB0aGlzLmRhdGFUYWJsZS5vZmZzZXQgPSAodGhpcy5tYXhQYWdlIC0gMSkgKiB0aGlzLmRhdGFUYWJsZS5saW1pdDtcbiAgfVxuXG4gIGtleVByZXNzKGV2ZW50OiBhbnkpIHtcbiAgICBsZXQgaW5wdXRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShldmVudC5jaGFyQ29kZSk7XG4gICAgaWYgKCEoTnVtYmVyKGlucHV0Q2hhcikgPj0gMCkpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG59XG4iXX0=